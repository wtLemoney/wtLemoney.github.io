<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wtLemoney</title>
  
  <subtitle>To be a happy&amp;lovely programmer...</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wtlemoney.github.io/"/>
  <updated>2018-04-16T01:44:06.458Z</updated>
  <id>https://wtlemoney.github.io/</id>
  
  <author>
    <name>wtLemoney</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ajax知识总结</title>
    <link href="https://wtlemoney.github.io/2018/04/15/ajax/"/>
    <id>https://wtlemoney.github.io/2018/04/15/ajax/</id>
    <published>2018-04-15T14:04:38.000Z</published>
    <updated>2018-04-16T01:44:06.458Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#1onload和onreadychange的不同">1.onload和onreadychange的不同</a></li><li><a href="#11-onload">1.1 onload</a></li><li><a href="#12-onreadychange">1.2 onreadychange</a></li><li><a href="#2服务器返回的数据类型对比">2.服务器返回的数据类型对比</a></li><li><a href="#3把字符串转化为json对象">3.把字符串转化为JSON对象</a></li><li><a href="#4原生js实现ajax">4.原生JS实现ajax</a></li></ul><!-- tocstop --><h4><span id="1onload和onreadychange的不同">1.onload和onreadychange的不同</span></h4><p>首先需要知道几个状态码的小知识。<br>&emsp;&emsp;readyState 状态码：</p><p>&emsp;&emsp;&emsp;&emsp;0:请求未初始化。还没有调用open方法</p><p>&emsp;&emsp;&emsp;&emsp;1:服务器连接已建立。open方法已被调用，但send方法还没有被调用</p><p>&emsp;&emsp;&emsp;&emsp;2:请求已接受。send方法以及被调用</p><p>&emsp;&emsp;&emsp;&emsp;3:请求处理中。服务器正在发送响应</p><p>&emsp;&emsp;&emsp;&emsp;4:请求已完成，响应发送完毕</p><p>&emsp;&emsp;HTTP 状态码(status)：<a id="more"></a></p><p>&emsp;&emsp;&emsp;&emsp;200 - 服务器成功返回网页</p><p>&emsp;&emsp;&emsp;&emsp;304 - 客户端已经执行了GET，但文件未变化。</p><p>&emsp;&emsp;&emsp;&emsp;403 - 禁止访问</p><p>&emsp;&emsp;&emsp;&emsp;404 - 请求的网页不存在</p><p>&emsp;&emsp;&emsp;&emsp;500 - 内部服务器出错</p><p>&emsp;&emsp;&emsp;&emsp;503 - 服务器暂时不可用<br>然后建立一个loadtest.txt文件作为ajax请求的测试url，注意一定要在本地服务器里面打开测试，不然请求文件会报跨域错误。</p><h4><span id="11-onload">1.1 onload</span></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'button'</span>).addEventListener(<span class="string">"click"</span>,loadText);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadText</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> xhr=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    xhr.open(<span class="string">'GET'</span>,<span class="string">"loadtext.txt"</span>,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Readystate："</span>,xhr.readyState);</span><br><span class="line"></span><br><span class="line">    xhr.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//readystate==4时才会进入onload,监听不到2和3</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Readystate："</span>,xhr.readyState);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><div align="center"><br>    <img src="/2018/04/15/ajax/11.png" width="320" height="100" alt="onload状态码结果"><br></div><br>如果要监听readystate为3的值，需要用到onprogress方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"Readystate："</span>,xhr.readyState);</span><br><span class="line">   xhr.onprogress=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//监听3</span></span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">"测试Readystate："</span>,xhr.readyState);</span><br><span class="line">   &#125;</span><br><span class="line">   xhr.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//readystate==4时才会进入onload,监听不到2和3</span></span><br></pre></td></tr></table></figure><br><br>测试结果如下：<br><div align="center"><br>    <img src="/2018/04/15/ajax/2.png" width="320" height="100" alt="onload状态码结果"><br></div><h4><span id="12-onreadychange">1.2 onreadychange</span></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadText</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> xhr=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    xhr.open(<span class="string">'GET'</span>,<span class="string">"loadtext.txt"</span>,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Readystate："</span>,xhr.readyState);</span><br><span class="line"></span><br><span class="line">    xhr.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//可以监听到所有的状态码2,3,4</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Readystate："</span>,xhr.readyState);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.responseText);<span class="comment">//在readyState=2和3的时候都打印responseText</span></span><br><span class="line">    &#125;</span><br><span class="line">    xhr.send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><p><div align="center"><br>    <img src="/2018/04/15/ajax/3.png" width="320" height="150" alt="onreadystate状态码结果"><br></div><br>看出onreadychange和onload方法的区别了昂。想要在readyState==4的时候再打印responseText，可以加一个条件判断：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">xhr.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//可以监听到所有的状态码2,3,4</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Readystate："</span>,xhr.readyState);</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.status==<span class="number">200</span>&amp;&amp;<span class="keyword">this</span>.readyState==<span class="number">4</span>)&#123;<span class="comment">//监听到4时再执行</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试结果：</p><p><div align="center"><br>    <img src="/2018/04/15/ajax/4.png" width="320" height="125" alt="onreadystate状态码结果"><br></div><br>一般在用ajax请求数据时，还会设置返回失败时的值。这时候把loadtest.txt改为loadtest1.txt，然后<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.status==<span class="number">200</span>&amp;&amp;<span class="keyword">this</span>.readyState==<span class="number">4</span>)&#123;<span class="comment">//监听4时再执行</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.responseText);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.status==<span class="number">404</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"请求的网页不存在"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试结果：</p><p><div align="center"><br>    <img src="/2018/04/15/ajax/5.png" width="320" height="180" alt="404结果"><br></div><br>注意：如果用POST请求向服务器发送数据，需要将“Content-type”的首部设置为“application/x-www-form-urlencoded”,它会告知服务器正在发送数据，并且数据已经符合URL编码了。<br>即：<code>xhr.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;)</code>,该方法必须在open()之后才能调用。</p><h4><span id="2服务器返回的数据类型对比">2.服务器返回的数据类型对比</span></h4><p>HTML片段：</p><ul><li>从服务器端发送的HTML代码在浏览器端不需要用JavaScript进行解析</li><li>HTML可读性好</li><li>HTML代码块与innerHTML属性搭配，效率高</li></ul><ul><li>若需要通过ajax更新一篇文档的多个部分，HTML不合适，可重用性低</li><li>innerHTML并非DOM标准</li></ul><p>XML文档：</p><ul><li>可移植性是其他数据格式无法比拟的，重用性高</li></ul><ul><li>实现过程较HTML片段要复杂许多</li><li>XML文件体积大。</li></ul><p>JSON文件：</p><ul><li>作为一种数据传输格式，JSON与XML相似，但是JSON更加灵巧</li><li>可重用</li><li>JSON不需要从服务器端发送含有特定内容类型的首部信息</li></ul><ul><li>语法国语严谨</li><li>代码不易读</li><li>eval函数存在风险</li></ul><p>对比：<br>若应用程序不需要与其他应用程序共享数据的时候，使用HTML片段来返回数据时是最简单的<br>如果数据需要重用，JSON文件是个不错的选择，它在性能和文件大小方面有有事（90%情况使用JSON）<br>当远程应用程序未知时，XML文档是首选，因为听说XML是“世界语”</p><h4><span id="3把字符串转化为json对象">3.把字符串转化为JSON对象</span></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonStr=<span class="string">'&#123;"name":"hhhhhaaaaa"&#125;'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(jsonStr.name);<span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用eval()方法,它可以把一个字符串转化为本地的JS代码来执行</span></span><br><span class="line"><span class="keyword">var</span> testStr=<span class="built_in">eval</span>(<span class="string">"("</span>+jsonStr+<span class="string">")"</span>);<span class="comment">//注意要加括号！把JSON对象转化为JSON字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(testStr.name);<span class="comment">//hhhhhaaaaa</span></span><br></pre></td></tr></table></figure><h4><span id="4原生js实现ajax">4.原生JS实现ajax</span></h4><p>下面这段代码是做项目写ajax请求时，经常使用的代码段，非常好用！<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1onload和onreadychange的不同&quot;&gt;1.onload和onreadychange的不同&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#11-onload&quot;&gt;1.1 onload&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#12-onreadychange&quot;&gt;1.2 onreadychange&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2服务器返回的数据类型对比&quot;&gt;2.服务器返回的数据类型对比&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3把字符串转化为json对象&quot;&gt;3.把字符串转化为JSON对象&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#4原生js实现ajax&quot;&gt;4.原生JS实现ajax&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;
&lt;h4 id=&quot;1-onload和onreadychange的不同&quot;&gt;&lt;a href=&quot;#1-onload和onreadychange的不同&quot; class=&quot;headerlink&quot; title=&quot;1.onload和onreadychange的不同&quot;&gt;&lt;/a&gt;1.onload和onreadychange的不同&lt;/h4&gt;&lt;p&gt;首先需要知道几个状态码的小知识。&lt;br&gt;&amp;emsp;&amp;emsp;readyState 状态码：&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;0:请求未初始化。还没有调用open方法&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;1:服务器连接已建立。open方法已被调用，但send方法还没有被调用&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;2:请求已接受。send方法以及被调用&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;3:请求处理中。服务器正在发送响应&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;4:请求已完成，响应发送完毕&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;HTTP 状态码(status)：&lt;/p&gt;
    
    </summary>
    
      <category term="Ajax请求" scheme="https://wtlemoney.github.io/categories/Ajax%E8%AF%B7%E6%B1%82/"/>
    
      <category term="HTTP" scheme="https://wtlemoney.github.io/categories/Ajax%E8%AF%B7%E6%B1%82/HTTP/"/>
    
      <category term="JavaScript" scheme="https://wtlemoney.github.io/categories/Ajax%E8%AF%B7%E6%B1%82/HTTP/JavaScript/"/>
    
    
      <category term="blogs" scheme="https://wtlemoney.github.io/tags/blogs/"/>
    
      <category term="JavaScript" scheme="https://wtlemoney.github.io/tags/JavaScript/"/>
    
      <category term="ajax" scheme="https://wtlemoney.github.io/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>令人迷惑的“构造函数”</title>
    <link href="https://wtlemoney.github.io/2018/04/14/%E5%8E%9F%E5%9E%8B/"/>
    <id>https://wtlemoney.github.io/2018/04/14/原型/</id>
    <published>2018-04-14T15:55:54.000Z</published>
    <updated>2018-04-14T15:57:53.053Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">   Foo.prototype.constructor === Foo;<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> a=<span class="keyword">new</span> Foo();</span><br><span class="line">   a.constructor === Foo;<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Foo.prototype默认有一个公有并且不可枚举的属性.constructor,但a.constructor === Foo不意味着a有一个指向Foo的.constructor属性。实际上,.constructor引用同样被委托给了Foo.prototype,而Foo.prototype.constructor默认指向Foo。<br>&emsp;&emsp;如果创建了一个新对象并替换了函数默认的.prototype对象引用,那么新对象并不会自动获得.constructor属性：<a id="more"></a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;<span class="comment">/* .. */</span>&#125;</span><br><span class="line">Foo.prototype =&#123;<span class="comment">/* .. */</span>&#125;<span class="comment">//创建一个新原型对象。丢失了.constructor属性</span></span><br><span class="line">Foo.prototype.constructor === Foo;<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a1=<span class="keyword">new</span> Foo();</span><br><span class="line">a1.constructor === Foo;<span class="comment">//false</span></span><br><span class="line">a1.constructor === <span class="built_in">Object</span>;<span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;可以手动添加一个符合正常行为的不可枚举属性.constructor,修复.constructor需要很多收到操作，所有这些都源于把“constructor”错误地理解为“有……构造”。手动添加.constructor属性：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;<span class="comment">/* .. */</span>&#125;</span><br><span class="line">Foo.prototype =&#123;<span class="comment">/* .. */</span>&#125;<span class="comment">//创建一个新原型对象。丢失了.constructor属性</span></span><br><span class="line"><span class="comment">//需要在Foo.prototype“修复”丢失的.constructor属性</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Foo.prototype,<span class="string">"constructor"</span>,&#123;</span><br><span class="line">    enumerable:<span class="literal">false</span>,</span><br><span class="line">    writable:<span class="literal">true</span>,</span><br><span class="line">    configurable:<span class="literal">true</span>,</span><br><span class="line">    value:Foo <span class="comment">//让.constructor指向Foo</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Foo&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;//...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   Foo.prototype.constructor === Foo;&lt;span class=&quot;comment&quot;&gt;//true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a=&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Foo();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   a.constructor === Foo;&lt;span class=&quot;comment&quot;&gt;//true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;Foo.prototype默认有一个公有并且不可枚举的属性.constructor,但a.constructor === Foo不意味着a有一个指向Foo的.constructor属性。实际上,.constructor引用同样被委托给了Foo.prototype,而Foo.prototype.constructor默认指向Foo。&lt;br&gt;&amp;emsp;&amp;emsp;如果创建了一个新对象并替换了函数默认的.prototype对象引用,那么新对象并不会自动获得.constructor属性：
    
    </summary>
    
      <category term="构造函数" scheme="https://wtlemoney.github.io/categories/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
      <category term="你不知道的JavaScript" scheme="https://wtlemoney.github.io/categories/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript/"/>
    
    
      <category term="blogs" scheme="https://wtlemoney.github.io/tags/blogs/"/>
    
      <category term="JavaScript" scheme="https://wtlemoney.github.io/tags/JavaScript/"/>
    
      <category term="原型" scheme="https://wtlemoney.github.io/tags/%E5%8E%9F%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>腾讯IMWeb前端训练营作业——经典面试题2</title>
    <link href="https://wtlemoney.github.io/2018/04/07/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95%E9%A2%982/"/>
    <id>https://wtlemoney.github.io/2018/04/07/腾讯面试题2/</id>
    <published>2018-04-07T12:59:48.000Z</published>
    <updated>2018-04-07T13:13:18.102Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#1-box-sizing常用的属性有哪些分别有什么作用">1. box-sizing常用的属性有哪些？分别有什么作用？</a></li><li><a href="#2-doctype作用标准模式和兼容模式各有什么区别">2. Doctype作用？标准模式和兼容模式各有什么区别？</a></li><li><a href="#3-html5为什么只需要写doctype-html">3. HTML5为什么只需要写&lt;!DOCTYPE html&gt;？</a></li><li><a href="#4-页面导入样式时使用link和import有什么区别">4. 页面导入样式时，使用link和@import有什么区别？</a></li><li><a href="#5-介绍一下你对浏览器内核的理解">5. 介绍一下你对浏览器内核的理解？</a></li><li><a href="#6-ie和dom事件流的区别">6. IE和DOM事件流的区别？</a></li><li><a href="#7-哪些地方会出现css阻塞或js阻塞">7. 哪些地方会出现CSS阻塞或js阻塞？</a></li><li><a href="#8-说说你对svg的理解">8. 说说你对SVG的理解？</a></li><li><a href="#9-如何视觉隐藏网页内容只让他们在屏幕阅读器中可用">9. 如何视觉隐藏网页内容，只让他们在屏幕阅读器中可用？</a></li><li><a href="#10-你如何对网站的文件和资源进行优化">10. 你如何对网站的文件和资源进行优化？</a></li><li><a href="#11web前端密码加密是否有意义">11.web前端密码加密是否有意义？</a></li><li><a href="#12平时如何管理你的项目">12.平时如何管理你的项目？</a></li></ul><!-- tocstop --><h4><span id="1-box-sizing常用的属性有哪些分别有什么作用">1. box-sizing常用的属性有哪些？分别有什么作用？</span></h4><p><strong>属性值</strong></p><ul><li>box-sizing：content-box</li><li>box-sizing：border-box</li><li>box-sizing：inherit</li></ul><p><strong>content-box</strong></p><ul><li>这是box-sizing的默认属性值</li><li>是CSS2.1中规定的宽度高度的显示行为</li><li>在CSS中定义的宽度和高度就对应到元素的内容框</li><li>在CSS中定义的宽度和高度之外绘制元素的内边距和边框</li></ul><p><strong>border-box</strong></p><ul><li>在CSS中微元素设定的宽度和高度就决定了元素的边框盒<a id="more"></a> </li><li>即为元素在设置内边距和边框是在已经设定好的宽度和高度之内进行绘制</li><li>CSS中设定的宽度和高度减去边框和内间距才能得到元素内容所占的实际宽度和高度</li></ul><p><strong>inherit</strong></p><ul><li>规定元素是从父元素那里继承box-sizing的属性值</li></ul><h4><span id="2-doctype作用标准模式和兼容模式各有什么区别">2. Doctype作用？标准模式和兼容模式各有什么区别？</span></h4><p><strong>作用</strong></p><ul><li>告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式（怪异模式）呈现。</li></ul><p><strong>语法</strong></p><ul><li>HTML 顶级元素 可用性 “注册//组织//类型 标签//定义 语言””URL”；</li></ul><p><strong>举例</strong></p><ul><li>&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.0//EN”&gt; </li><li>&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.0 Strict//EN”&gt;<br>&emsp;&emsp;其中，DTD的是W3C所发布的一个文档类型定义，简单的说，就是告诉浏览器你的这个HTML，是根据哪个标准写的，解析的时候用哪个标准解析。</li></ul><p><strong>标准模式与兼容模式（怪异模式）各有什么区别?</strong></p><ul><li>标准模式的排版和JS运作模式都是以该浏览器支持的最高标准运行。</li><li>在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。简单的说，就是尽可能的显示能显示的东西给用户看。</li></ul><p><strong>具体区别</strong></p><ul><li><p>width不同<br>&emsp;&emsp;在严格模式中 ：width是内容宽度 ，元素真正的宽度 = margin-left + border-left-width + padding-left + width + padding-right + border-right- width +  margin-right;<br>&emsp;&emsp;在兼容模式中 ：width则是元素的实际宽度 ，内容宽度 = width - ( padding-left + padding-right + border-left-width + border-right-width);</p></li><li><p>兼容模式下可设置百分比的高度和行内元素的高宽<br>&emsp;&emsp;在Standards模式下，给span等行内元素设置wdith和height都不会生效，而在兼容模式下，则会生效。<br>&emsp;&emsp;在standards模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置高度，子元素设置一个百分比的高度是无效的。</p></li><li><p>用margin:0 auto设置水平居中在IE下会失效<br>&emsp;&emsp;使用margin:0 auto在standards模式下可以使元素水平居中，但在兼容模式下却会失效（用text-align属性解决）</p></li><li><p>兼容模式下Table中的字体属性不能继承上层的设置，white-space:pre会失效，设置图片的padding会失效</p></li></ul><h4><span id="3-html5为什么只需要写ltdoctype-htmlgt">3. HTML5为什么只需要写&lt;!DOCTYPE html&gt;？</span></h4><p>&emsp;&emsp;html5不基于SGML(标准通用标记语言)，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照他们应该的方式来运行）。而HTML4.01基于SGML，所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。</p><h4><span id="4-页面导入样式时使用link和import有什么区别">4. 页面导入样式时，使用link和@import有什么区别？</span></h4><p>外部样式表另一种写法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type=”text/css”&gt;</span><br><span class="line">    @<span class="keyword">import</span> url（“a.css”）；</span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>与link区别</strong>:</p><ul><li><p>老祖宗的差别。link属于XHTML标签，而@import完全是CSS提供的一种方式。link标签除了可以加载CSS外，还可以做很多其它的事情，比如定义RSS，定义rel连接属性等，@import就只能加载CSS了。 　</p></li><li><p>加载顺序的差别。当一个页面被加载的时候（就是被浏览者浏览的时候），link引用的CSS会同时被加载，而@import引用的CSS会等到页面全部被下载完再被加载。所以有时候浏览@import加载CSS的页面时开始会没有样式（就是闪烁），网速慢的时候还挺明显（梦之都加载CSS 的方式就是使用@import，一边下载一边浏览梦之都网页时，就会出现上述问题）。 　　</p></li><li><p>兼容性的差别。由于@import是CSS2.1提出的，所以老的浏览器不支持，@import只有在IE5以上的才能识别，而link标签无此问题。 　　</p></li></ul><ul><li>使用dom控制样式时的差别。当使用javascript控制dom去改变样式的时候，只能使用link标签，因为@import不是dom可以控制的。</li></ul><h4><span id="5-介绍一下你对浏览器内核的理解">5. 介绍一下你对浏览器内核的理解？</span></h4><p>&emsp;&emsp;主要分成两个部分：渲染引擎(Render Engine)和JS引擎。最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向与只指渲染引擎。</p><ul><li><p><strong>渲染引擎</strong>：负责取得网页的内容(html,xml和图像等)，整理讯息(例如假如css)，以及计算网页的显示方式，然后输出到显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不同，这也是网页编写者需要在不同内核的浏览器中测试网页显示效果的原因。所有网页浏览器、电子邮件客户端以及它需要编辑、显示网络内容的应用程序都需要内核。</p></li><li><p><strong>JS引擎</strong>：解析和执行JavaScript来实现网页的动态效果。</p></li><li><p><strong>常见的浏览器内核有哪些？</strong><br>Trident内核：IE，360，搜狗浏览器，百度浏览器（早期版本）；<br>Gecko内核：Netscape6及以上版本，Firefox<br>Presto内核：Opera前内核（已废弃）<br>Blink内核：Opera<br>Webkit内核：Safari，Chrome，Android默认浏览器</p></li><li><p><strong>常见的JS引擎有哪些？</strong><br>现今比较出名的有Chorme浏览器的V8引擎、Safari浏览器的Chakra（查克拉）、JSCore(FF4.0+)。</p></li></ul><h4><span id="6-ie和dom事件流的区别">6. IE和DOM事件流的区别？</span></h4><ul><li><p><strong>事件流的区别 </strong></p><p>IE采用冒泡型事件<br>Netscape使用捕获型事件<br>DOM使用先捕获后冒泡型事件 </p></li></ul><p>示例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt; </span><br><span class="line">&lt;div&gt; </span><br><span class="line">&lt;button&gt;点击这里&lt;<span class="regexp">/button&gt; </span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt; </span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br></pre></td></tr></table></figure></p><p>冒泡型事件模型： button-&gt;div-&gt;body (IE事件流) </p><p>捕获型事件模型： body-&gt;div-&gt;button (Netscape事件流) </p><p>DOM事件模型： body-&gt;div-&gt;button-&gt;button-&gt;div-&gt;body (先捕获后冒泡)</p><ul><li><p><strong>事件侦听函数的区别 </strong></p><p>IE使用: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">Object</span>].attachEvent(<span class="string">"name_of_event_handler"</span>, fnHandler); <span class="comment">//绑定函数 </span></span><br><span class="line">[<span class="built_in">Object</span>].detachEvent(<span class="string">"name_of_event_handler"</span>, fnHandler); <span class="comment">//移除绑定</span></span><br></pre></td></tr></table></figure><p>DOM使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">Object</span>].addEventListener(<span class="string">"name_of_event"</span>, fnHandler, bCapture); <span class="comment">//绑定函数 </span></span><br><span class="line">[<span class="built_in">Object</span>].removeEventListener(<span class="string">"name_of_event"</span>, fnHandler, bCapture); <span class="comment">//移除绑定</span></span><br></pre></td></tr></table></figure><p>bCapture参数用于设置事件绑定的阶段，true为捕获阶段，false为冒泡阶段。</p></li><li><p><strong>阻止事件的传播的区别</strong></p><p>无论是事件冒泡还是事件捕获都是可以阻止的。</p><p>（1）阻止事件的传播方法：在W3C标准中，<code>stopPropagation()</code>。在IE中，通过设置<code>cancelBubble = true</code>;<br>（2）阻止事件的默认行为：在W3C标准中，使用<code>preventDefault()</code>。在IE中通过设置<code>window.event.returnValue = false</code>;</p></li></ul><h4><span id="7-哪些地方会出现css阻塞或js阻塞">7. 哪些地方会出现CSS阻塞或js阻塞？</span></h4><p><strong>CSS怎么会阻塞加载了？</strong><br>&emsp;&emsp;CSS本来是可以并行下载的，在什么情况下会出现阻塞加载？(在测试观察中,IE6下CSS都是阻塞加载）。当CSS后面跟着嵌入的JS的时候,该CSS就会出现阻塞后面资源下载的情况，而当把嵌入JS放到CSS前面,就不会出现阻塞的情况了。<br>根本原因？<br>&emsp;&emsp;因为浏览器会维持html中css和js的顺序,样式表必须在嵌入的JS执行前先加载、解析完。<br>&emsp;&emsp;而嵌入的JS会阻塞后面的资源加载,所以就会出现上面CSS阻塞下载的情况。<br>嵌入JS应该放在什么位置？<br>&emsp;&emsp;1）放在底部,虽然放在底部照样会阻塞所有呈现,但不会阻塞资源下载。<br>&emsp;&emsp;2）如果嵌入JS放在head中,请把嵌入JS放在CSS头部。<br>&emsp;&emsp;3）使用defer（只支持IE）<br>&emsp;&emsp;4）不要在嵌入的JS中调用运行时间较长的函数,如果一定要用,可以用<code>setTimeout</code>来调用<br><strong>js的阻塞特性</strong>：<br>&emsp;&emsp;所有浏览器在下载JS的时候,会阻止一切其他活动,比如其他资源的下载,内容的呈现等等。直到JS下载、解析、执行完毕后才开始继续并行下载其他资源并呈现内容。为了提高用户体验,新一代浏览器都支持并行下载JS,但是JS下载仍然会阻塞其它资源的下载（例如.图片,css文件等）。<br>&emsp;&emsp;由于浏览器为了防止出现JS修改DOM树,需要重新构建DOM树的情况,所以就会阻塞其他的下载和呈现。嵌入JS会阻塞所有内容的呈现,而外部JS只会阻塞其后内容的显示,2种方式都会阻塞其后资源的下载。也就是说外部样式不会阻塞外部脚本的加载,但会阻塞外部脚本的执行。</p><h4><span id="8-说说你对svg的理解">8. 说说你对SVG的理解？</span></h4><ul><li>SVG 指可伸缩矢量图形 (Scalable Vector Graphics)</li><li>SVG 使用 XML 格式定义用于网络的基于矢量的图形</li><li>SVG 图像在放大或改变尺寸的情况下其图形质量不会有所损失，图像可在任何的分辨率下被高质量地打印</li><li>SVG 是万维网联盟的标准，与诸如 DOM 和 XSL 之类的 W3C 标准是一个整体</li><li>SVG 图像中的文本是可选的，同时也是可搜索的（很适合制作地图）</li></ul><h4><span id="9-如何视觉隐藏网页内容只让他们在屏幕阅读器中可用">9. 如何视觉隐藏网页内容，只让他们在屏幕阅读器中可用？</span></h4><ul><li><p>display:none;的缺陷搜索引擎可能认为被隐藏的文字属于垃圾信息而被忽略屏幕阅读器（是为视觉上有障碍的人设计的读取屏幕内容的程序）会忽略被隐藏的文字。</p></li><li><p>visibility:hidden;的缺陷这个大家应该比较熟悉就是隐藏的内容会占据他所应该占据物理空间</p></li><li><p>overflow:hidden;一个比较合理的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.texthidden&#123;<span class="attr">display</span>:block;<span class="comment">/*统一转化为块级元素*/</span></span><br><span class="line">overflow:hidden;width:<span class="number">0</span>;height:<span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure><p>就像上面的一段CSS所展示的方法，将宽度和高度设定为0，然后超过部分隐藏，就会弥补上述一、二方法中的缺陷，也达到了隐藏内容的目的。</p></li></ul><h4><span id="10-你如何对网站的文件和资源进行优化">10. 你如何对网站的文件和资源进行优化？</span></h4><ul><li><p>文件合并（目的是减少http请求）：使用css sprites合并图片，一个网站经常使用小图标和小图片进行美化，但是很遗憾这些小图片占用了大量的HTTP请求，因此可以采用sprites的方式把所有的图片合并成一张图片 ，可以通过相关工具在线合并，也可以在ps中合并。</p></li><li><p>使用CDN（内容分发网络）加速，降低通信距离。</p></li><li><p>缓存的使用，添加Expire/Cache-Control头。</p></li><li><p>启用Gzip压缩文件。</p></li><li><p>将css放在页面最上面,将script放在页面最下面,避免在css中使用表达式。</p></li><li><p>将css, js都放在外部文件中。</p></li><li><p>减少DNS查询。</p></li><li><p>文件压缩：最小化css, js，减小文件体积。</p></li><li><p>使用AJAX缓存，让网站内容分批加载，局部更新。</p></li></ul><h4><span id="11web前端密码加密是否有意义">11.web前端密码加密是否有意义？</span></h4><ul><li><p><strong>前端加密的意义</strong> </p><p>1）在 HTTP 协议下，数据是明文传输，传输过程中网络嗅探可直接获取其中的数据。如用户的密码和信用卡相关的资料，一旦被中间人获取，会给用户带来极大的安全隐患。<br>2）前端使用哈希算法，不仅可以帮助后端分担部分计算压力，还可以增加撞库成本。<br>3）另一方面，在非加密的传输过程中，攻击者可更改数据或插入恶意的代码等。HTTPS 的诞生就是为了解决中间人攻击的问题，但如今 HTTPS 的使用情况在国内并不乐观，基本是因为成本或者性能的考量。</p></li><li><p>那么问题来了，如果仍然使用 HTTP 协议，怎么样一定程度保证用户的数据安全？ </p><p>前端加密，即在数据发送前，将数据进行哈希或使用公钥加密。如果数据被中间人获取，拿到的则不再是明文。</p></li><li><p><strong>传md5和传明文一样？</strong><br>绝对不一样啊。链路被监听的时候，攻击人直接就拿到明文密码了，有很多人都习惯用一个密码的。明文的话，相当于直接把用户n多个网站的密码爆了，拿到md5的话，只有自己的网站密码被爆。对用户的危害范围明显缩小了好么。多少次用户icloud艳照泄露，最后都不是苹果的锅。。是别的网站被脱了好么。</p><p>有一种有效实践是发送用户密码+时间戳的md5值。这样可以有效避免被监听。当然还要做一点客户端和服务器端时间差计算的工作量。哪怕被监听。攻击人拿到的加密后密码也很快失效。在做一点单帐号单登录的措施，用户密码安全性还是可以得到很大的保证的。</p></li><li><p>前端 hash 的好处 </p><p>（1）避免明文密码在传输中被获取<br>（2）保证后端日志等不会记录明文密码（也可以防止内鬼盗窃）<br>（3）保证后端内存中无用户明文密码，在 dump 等情况发生时不会出现泄露问题 </p></li></ul><h4><span id="12平时如何管理你的项目">12.平时如何管理你的项目？</span></h4><ul><li>先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等</li><li>编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）</li><li>标注样式编写人，各模块都及时标注（标注关键样式调用的地方）</li><li>页面进行标注（例如 页面 模块 开始和结束）</li><li>CSS 跟 HTML 分文件夹并行存放，命名都得统一，如index.css和index.html</li><li>JS 分文件夹存放，命名以该 JS 功能为准的英文翻译</li><li>图片采用整合的png8格式，尽量整合在一起使用，方便将来的管理。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-box-sizing常用的属性有哪些分别有什么作用&quot;&gt;1. box-sizing常用的属性有哪些？分别有什么作用？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-doctype作用标准模式和兼容模式各有什么区别&quot;&gt;2. Doctype作用？标准模式和兼容模式各有什么区别？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3-html5为什么只需要写doctype-html&quot;&gt;3. HTML5为什么只需要写&amp;lt;!DOCTYPE html&amp;gt;？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#4-页面导入样式时使用link和import有什么区别&quot;&gt;4. 页面导入样式时，使用link和@import有什么区别？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#5-介绍一下你对浏览器内核的理解&quot;&gt;5. 介绍一下你对浏览器内核的理解？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#6-ie和dom事件流的区别&quot;&gt;6. IE和DOM事件流的区别？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#7-哪些地方会出现css阻塞或js阻塞&quot;&gt;7. 哪些地方会出现CSS阻塞或js阻塞？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#8-说说你对svg的理解&quot;&gt;8. 说说你对SVG的理解？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#9-如何视觉隐藏网页内容只让他们在屏幕阅读器中可用&quot;&gt;9. 如何视觉隐藏网页内容，只让他们在屏幕阅读器中可用？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#10-你如何对网站的文件和资源进行优化&quot;&gt;10. 你如何对网站的文件和资源进行优化？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#11web前端密码加密是否有意义&quot;&gt;11.web前端密码加密是否有意义？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#12平时如何管理你的项目&quot;&gt;12.平时如何管理你的项目？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;
&lt;h4 id=&quot;1-box-sizing常用的属性有哪些？分别有什么作用？&quot;&gt;&lt;a href=&quot;#1-box-sizing常用的属性有哪些？分别有什么作用？&quot; class=&quot;headerlink&quot; title=&quot;1. box-sizing常用的属性有哪些？分别有什么作用？&quot;&gt;&lt;/a&gt;1. box-sizing常用的属性有哪些？分别有什么作用？&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;属性值&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;box-sizing：content-box&lt;/li&gt;
&lt;li&gt;box-sizing：border-box&lt;/li&gt;
&lt;li&gt;box-sizing：inherit&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;content-box&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这是box-sizing的默认属性值&lt;/li&gt;
&lt;li&gt;是CSS2.1中规定的宽度高度的显示行为&lt;/li&gt;
&lt;li&gt;在CSS中定义的宽度和高度就对应到元素的内容框&lt;/li&gt;
&lt;li&gt;在CSS中定义的宽度和高度之外绘制元素的内边距和边框&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;border-box&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在CSS中微元素设定的宽度和高度就决定了元素的边框盒
    
    </summary>
    
      <category term="腾讯训练营" scheme="https://wtlemoney.github.io/categories/%E8%85%BE%E8%AE%AF%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
      <category term="面试" scheme="https://wtlemoney.github.io/categories/%E8%85%BE%E8%AE%AF%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="总结" scheme="https://wtlemoney.github.io/categories/%E8%85%BE%E8%AE%AF%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%9D%A2%E8%AF%95/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="blogs" scheme="https://wtlemoney.github.io/tags/blogs/"/>
    
      <category term="interview" scheme="https://wtlemoney.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>腾讯IMWeb前端训练营作业——经典面试题1</title>
    <link href="https://wtlemoney.github.io/2018/04/03/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95%E9%A2%981/"/>
    <id>https://wtlemoney.github.io/2018/04/03/腾讯面试题1/</id>
    <published>2018-04-03T14:05:53.000Z</published>
    <updated>2018-04-07T13:10:33.830Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;这些面试题是我之前参加腾讯前端训练营的时候，每天的一些面试题作业。最近自己参加暑期实习生面试的时候，也被问到过一些类似的问题。所以我整理总结了以前的面试题，通过自己搜索资料学习总结。答案有些是结合自己的理解，有些是网络上一些回答的比较好的答案，仅供参考。</p><!-- toc --><ul><li><a href="#1什么是盒子模型">1.什么是盒子模型？</a></li><li><a href="#2简述一下src与href的区别">2.简述一下src与href的区别？</a></li><li><a href="#3怎样添加-移除-移动-复制-创建和查找节点">3.怎样添加、移除、移动、复制、创建和查找节点？</a></li><li><a href="#4一次完整的http事务是怎样的一个过程">4.一次完整的HTTP事务是怎样的一个过程？</a></li><li><a href="#5你所了解的web攻击技术">5.你所了解的web攻击技术？</a></li><li><a href="#6ajax是什么ajax的交互原理同步和异步的区别">6.ajax是什么？ajax的交互原理？同步和异步的区别？</a></li><li><a href="#4什么叫优雅降级和渐进增强">4.什么叫优雅降级和渐进增强？</a></li><li><a href="#5在javascript中什么是伪数组如何将伪数组转化为标准数组">5.在JavaScript中什么是伪数组？如何将伪数组转化为标准数组？</a></li><li><a href="#6浏览器本地储存">6.浏览器本地储存？</a></li><li><a href="#7线程和进程的区别">7.线程和进程的区别？</a></li><li><a href="#8请说出三种减少页面加载时间的方法">8.请说出三种减少页面加载时间的方法？</a></li><li><a href="#9http状态码">9.HTTP状态码？</a></li><li><a href="#10请解释javascript的同源策略">10.请解释JavaScript的同源策略？</a></li><li><a href="#11get和post的区别何时使用post">11.get和post的区别，何时使用post？</a></li><li><a href="#12-对前端工程师这个职位是怎么样理解的">12. 对前端工程师这个职位是怎么样理解的？</a></li></ul><!-- tocstop --><h4><span id="1什么是盒子模型">1.什么是盒子模型？</span></h4><p><strong>两种</strong>：IE盒子模型、标准W3C盒子模型，包括content、padding、margin、border。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IE8的width=border-left+padding-left+内容宽度+padding-right+border-right;  </span><br><span class="line">IE8的height=border-top+padding-top+内容高度+padding-bottom+border-bottom; </span><br><span class="line">w3c规定的width=内容宽度; </span><br><span class="line">w3c规定的height=内容高度;</span><br></pre></td></tr></table></figure></p><p>这样有可能导致不同浏览器下获取的width或height的值不同,幸好jquery提供了另外两个方法:<a id="more"></a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">innerWidth():padding-left+内容宽度+padding-right; </span><br><span class="line">outerWidth():border-left+padding-left+内容宽度+padding-right+border-right; </span><br><span class="line">outerWidth(<span class="literal">true</span>):margin-left+border-left+padding-left+内容宽度+padding-right+border-right+margin-right;</span><br></pre></td></tr></table></figure></p><h4><span id="2简述一下src与href的区别">2.简述一下src与href的区别？</span></h4><p><strong>src</strong>指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src =<span class="string">"js.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。<br><strong>href</strong>指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果我们在文档中添加<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link href=<span class="string">"common.css"</span> rel=<span class="string">"stylesheet"</span>/&gt;</span><br></pre></td></tr></table></figure></p><p>那么浏览器会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用link方式来加载css，而不是使用@import方式。</p><h4><span id="3怎样添加-移除-移动-复制-创建和查找节点">3.怎样添加、移除、移动、复制、创建和查找节点？</span></h4><p>&emsp;1）创建新节点<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">createDocumentFragment() <span class="comment">//创建一个DOM片段</span></span><br><span class="line">createElement() <span class="comment">//创建一个具体的元素</span></span><br><span class="line">createTextNode() <span class="comment">//创建一个文本节点</span></span><br></pre></td></tr></table></figure></p><p>&emsp;2）添加、移除、替换、插入<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">appendChild() <span class="comment">//添加</span></span><br><span class="line">removeChild() <span class="comment">//移除</span></span><br><span class="line">replaceChild() <span class="comment">//替换</span></span><br><span class="line">insertBefore() <span class="comment">//之前插入</span></span><br><span class="line">insertAfter() <span class="comment">//之后插入</span></span><br><span class="line">cloneNode() <span class="comment">//复制</span></span><br></pre></td></tr></table></figure></p><p>&emsp;3）查找<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getElementsByTagName() <span class="comment">//通过标签名称</span></span><br><span class="line">getElementsByName() <span class="comment">//通过元素的Name属性的值</span></span><br><span class="line">getElementById() <span class="comment">//通过元素Id，唯一性</span></span><br><span class="line"><span class="built_in">document</span>.getElementsByClassName(<span class="string">""</span>)  <span class="comment">//通过类查找</span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">""</span>)</span><br></pre></td></tr></table></figure></p><h4><span id="4一次完整的http事务是怎样的一个过程">4.一次完整的HTTP事务是怎样的一个过程？</span></h4><p>&emsp;&emsp;当我们在浏览器的地址栏输入URL ，然后回车，回车这一瞬间到看到页面到底发生了什么呢？<br>&emsp;&emsp;域名解析 –&gt; 发起TCP的3次握手 –&gt; 建立TCP连接后发起http请求 –&gt; 服务器响应http请求，浏览器得到html代码 –&gt; 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） –&gt; 浏览器对页面进行渲染呈现给用户  </p><h4><span id="5你所了解的web攻击技术">5.你所了解的web攻击技术？</span></h4><p>&emsp;&emsp;<strong>XSS：跨站脚本攻击</strong>（Cross Site Scripting）<br>攻击者通过注入非法的html标签或者javascript代码，从而当用户浏览该网页时，控制用户浏览器。本质：内容没有过滤导致浏览器将攻击者的输入当代码执行。<br>&emsp;&emsp;<strong>CSRF：跨站点请求伪造</strong>（Cross-Site Request Forgeries）<br>冒充用户发起请求，完成一些违背用户意愿的事情（如修改用户信息，删除评论等）。本质：浏览器在发送HTTP请求时自动带上cookie，而一般网站的session都存在cookie里面。防御：get/post、验证码、请求来源限制、token等。<br>&emsp;&emsp;<strong>clickjacking：点击劫持</strong><br>利用透明的按钮或连接做成陷阱，覆盖在Web网页之上。防御：X-FRAME-OPTIONS(用来给浏览器指示允许一个页面可否在<code>&lt;frame&gt;、&lt;object&gt;</code>等中展现的标记。网站可使用此功能，确保自己网站没有被嵌到别人网站中去)</p><h4><span id="6ajax是什么ajax的交互原理同步和异步的区别">6.ajax是什么？ajax的交互原理？同步和异步的区别？</span></h4><p>&emsp;&emsp;<strong>AJAX</strong> = 异步 JavaScript 和 XML，是一种用于创建快速动态网页的技术。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。<br>&emsp;&emsp;<strong>缺点</strong>：ajax用XHR对象做出的请求不会记录在浏览器的历史中。如果你的用户习惯使用浏览器的”后退”按钮在web应用中进行导航，就可能会产生问题。另外，ajax也难以避免一些已知的安全弱点，诸如跨站点脚步攻击、SQL注入攻击和基于credentials的安全漏洞等。</p><p>&emsp;&emsp;<strong>交互原理</strong>：通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。XMLHttpRequest这个对象的属性：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">onreadystatechange 每次状态改变所触发事件的事件处理程序。</span><br><span class="line">  　　responseText       从服务器进程返回数据的字符串形式。</span><br><span class="line">  　　responseXML        从服务器进程返回的DOM兼容的文档数据对象。</span><br><span class="line">  　　status             从服务器返回的数字代码，比如常见的<span class="number">404</span>（未找到）和<span class="number">200</span>（已就绪）</span><br><span class="line">  　　status Text        伴随状态码的字符串信息</span><br><span class="line">  　　readyState         对象状态值</span><br><span class="line">　　　　<span class="number">0</span> (未初始化)      对象已建立，但是尚未初始化（尚未调用open方法）</span><br><span class="line">　　　　<span class="number">1</span> (初始化)        对象已建立，尚未调用send方法</span><br><span class="line">　　　　<span class="number">2</span> (发送数据)     send方法已调用，但是当前的状态及http头未知</span><br><span class="line">　　　　<span class="number">3</span> (数据传送中)    已接收部分数据，因为响应及http头不全，这时通过responseBody和responseText获取部分数据会出现错误</span><br><span class="line">　　　　<span class="number">4</span> (完成)         数据接收完毕,此时可以通过通过responseXml和responseText获取完整的回应数据</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<strong>异步传输</strong>：是面向字符的传输，它的单位是字符；异步传输是将比特分成小组来进行传送。一般每个小组是一个8位字符，在每个小组的头部和尾部都有一个开始位和一个停止位，它在传送过程中接收方和发送方的时钟不要求一致，也就是说，发送方可以在任何时刻发送这些小组，而接收方并不知道它什么时候到达。<br>&emsp;&emsp;<strong>同步传输</strong>：是面向比特的传输，它的单位是桢，它传输的时候要求接受方和发送方的时钟是保持一致的。同步传输的比特分组要大得多。它不是独立地发送每个字符，每个字符都有自己的开始位和停止位，而是把它们组合起来一起发送。同步传输通常要比异步传输快速得多。接收方不必对每个字符进行开始和停止的操作。一旦检测到帧同步字符，它就在接下来的数据到达时接收它们。另外，同步传输的开销也比较少。   </p><h4><span id="4什么叫优雅降级和渐进增强">4.什么叫优雅降级和渐进增强？</span></h4><p>&emsp;&emsp;<strong>优雅降级</strong>：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了,为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效.<br>&emsp;&emsp;<strong>渐进增强</strong>：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。</p><h4><span id="5在javascript中什么是伪数组如何将伪数组转化为标准数组">5.在JavaScript中什么是伪数组？如何将伪数组转化为标准数组？</span></h4><p>&emsp;&emsp;<strong>伪数组</strong>（类数组）：无法直接调用数组方法或期望length属性有什么特殊的行为，但仍可以用真正数组的遍历方法遍历它们。典型的是函数的argument参数，还有像调用<code>getElementByTagName</code>,<code>document.childNodes</code>之类的，它们都返回NodeList对象都属于伪数组。<br>&emsp;&emsp;可以通过Array.prototype.slice.call(fakeArray)将伪数组转化为真正的Array对象。</p><h4><span id="6浏览器本地储存">6.浏览器本地储存？</span></h4><p>&emsp;&emsp;在 HTML5 中提供了 sessionStorage 和 localStorage 。<br>&emsp;&emsp;<strong>sessionStorage</strong>：用于本地存储一个会话（ session ）中的数据，这些数据只有在同一个会话中的页面才能访问，会话结束后数据随之销毁。因此它不是一种持久化的本地存储，仅仅是会话级别的存储。<br>&emsp;&emsp;<strong>localStorage</strong>：用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。IE8及以上都兼容。<br>&emsp;&emsp;<strong>cookie</strong>：当用户访问了某个网站（网页）时，我们就可通过cookie来向访问者电脑上存储数据。或者，某些网站为了辨别用户身份，进行session跟踪而存储在用户本地终端上的数据（加密）。cookie值既可以设置，也可以读取。如何工作：1）当网页要发http请求时，浏览器会先检查是否有相应的cookie，有则自动添加在request header中的字段中。2）对于那种设置“每次请求都要携带的信息”（最典型：身份认证信息）特别适合放在cookie中，其他类型的数据就不适合了。</p><h4><span id="7线程和进程的区别">7.线程和进程的区别？</span></h4><p>&emsp;&emsp;进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。以多进程形式，允许多个任务同时运行；以多线程形式，允许单个任务分成不同的部分运行；</p><h4><span id="8请说出三种减少页面加载时间的方法">8.请说出三种减少页面加载时间的方法？</span></h4><p>&emsp;&emsp;1）优化图片<br>&emsp;&emsp;2）图像格式的选择（GIF：提供的颜色较少，可用在一些对颜色要求不高的地方）<br>&emsp;&emsp;3）优化CSS（压缩合并css，如 margin-top, margin-left…)<br>&emsp;&emsp;4）网址后加斜杠（如<a href="http://www.campr.com/目录，会判断这个目录是什么文件类型，或者是目录。）" target="_blank" rel="noopener">www.campr.com/目录，会判断这个目录是什么文件类型，或者是目录。）</a><br>&emsp;&emsp;5）标明高度和宽度（如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小，如果图片很多，浏览器需要不断地调整页面。这不但影响速度，也影响浏览体验。当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加载后面的内容。从而加载时间快了，浏览体验也更好了）<br>&emsp;&emsp;6）减少http请求（合并文件，合并图片）CSS精灵，将JS代码写在body后面</p><h4><span id="9http状态码">9.HTTP状态码？</span></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>xx: 信息性状态码，表示服务器接收到请求正在处理。</span><br><span class="line"><span class="number">2</span>xx: 成功状态码，表示服务器正确处理完请求。</span><br><span class="line"><span class="number">3</span>xx: 重定向状态码，表示请求的资源位置发生改变，需要重新请求。<span class="number">301</span>永久重定向，<span class="number">302</span>临时重定向。</span><br><span class="line"><span class="number">4</span>xx: 客户端错误状态码，服务器无法处理该请求。 <span class="number">404</span> not found</span><br><span class="line"><span class="number">5</span>xx: 服务器错误状态码，服务器处理请求出错。</span><br><span class="line"></span><br><span class="line"><span class="number">100</span> Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息</span><br><span class="line"><span class="number">200</span> OK 正常返回信息</span><br><span class="line"><span class="number">201</span> Created 请求成功并且服务器创建了新的资源</span><br><span class="line"><span class="number">202</span> Accepted 服务器已接受请求，但尚未处理</span><br><span class="line"><span class="number">301</span> Moved Permanently 请求的网页已永久移动到新位置</span><br><span class="line"><span class="number">302</span> Found 临时性重定向</span><br><span class="line"><span class="number">303</span> See Other 临时性重定向，且总是使用 GET 请求新的 URI</span><br><span class="line"><span class="number">304</span> Not Modified 自从上次请求后，请求的网页未修改过</span><br><span class="line"><span class="number">400</span> Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求</span><br><span class="line"><span class="number">401</span> Unauthorized 请求未授权</span><br><span class="line"><span class="number">403</span> Forbidden 禁止访问</span><br><span class="line"><span class="number">404</span> Not Found 找不到如何与 URI 相匹配的资源</span><br><span class="line"><span class="number">500</span> Internal Server <span class="built_in">Error</span> 最常见的服务器端错误</span><br><span class="line"><span class="number">503</span> Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）</span><br></pre></td></tr></table></figure><h4><span id="10请解释javascript的同源策略">10.请解释JavaScript的同源策略？</span></h4><p>&emsp;&emsp;<strong>同源策略</strong>是客户端脚本（尤其是Javascript）的重要的安全度量标准，目的是防止某个文档或脚本从多个不同源装载。同源策略：协议，域名，端口相同，它是一种安全协议，指一段脚本只能读取来自同一来源的窗口和文档的属性，无法访问其它域的资源。</p><h4><span id="11get和post的区别何时使用post">11.get和post的区别，何时使用post？</span></h4><p>&emsp;&emsp;<strong>GET</strong>：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符<br>&emsp;&emsp;<strong>POST</strong>：一般用于修改服务器上的资源，对所发送的信息没有限制<br>&emsp;&emsp;HTTP中的GET，POST，PUT，DELETE就对应着对这个资源的查，改，增，删4个操作。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息。<br>&emsp;&emsp;在以下情况中，请使用 POST 请求：<br>&emsp;&emsp;1）无法使用缓存文件（更新服务器上的文件或数据库）<br>&emsp;&emsp;2）向服务器发送大量数据（POST 没有数据量限制）<br>&emsp;&emsp;3）发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠<br>&emsp;&emsp;安全性：<br>&emsp;&emsp;1）GET不会修改服务端数据，POST可以修改数据<br>&emsp;&emsp;2）URL方式发起GET请求，参数会明文暴露<br>&emsp;&emsp;3）使用GET提交数据还可能会造成Cross-site request forgery攻击<br>&emsp;&emsp;4）本质上安全性无区别</p><h4><span id="12-对前端工程师这个职位是怎么样理解的">12. 对前端工程师这个职位是怎么样理解的？</span></h4><p>前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。</p><ul><li><p>实现界面交互</p></li><li><p>提升用户体验</p></li><li><p>有了Node.js，前端可以实现服务端的一些事情</p></li><li><p>前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好</p></li><li><p>参与项目，快速高质量完成实现效果图，精确到1px</p></li><li><p>与团队成员，UI设计，产品经理的沟通</p></li><li><p>做好的页面结构，页面重构和用户体验</p></li><li><p>处理hack，兼容、写出优美的代码格式</p></li><li><p>针对服务器的优化、拥抱最新前端技术</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;这些面试题是我之前参加腾讯前端训练营的时候，每天的一些面试题作业。最近自己参加暑期实习生面试的时候，也被问到过一些类似的问题。所以我整理总结了以前的面试题，通过自己搜索资料学习总结。答案有些是结合自己的理解，有些是网络上一些回答的比较好的答案，仅供参考。&lt;/p&gt;
&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1什么是盒子模型&quot;&gt;1.什么是盒子模型？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2简述一下src与href的区别&quot;&gt;2.简述一下src与href的区别？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3怎样添加-移除-移动-复制-创建和查找节点&quot;&gt;3.怎样添加、移除、移动、复制、创建和查找节点？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#4一次完整的http事务是怎样的一个过程&quot;&gt;4.一次完整的HTTP事务是怎样的一个过程？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#5你所了解的web攻击技术&quot;&gt;5.你所了解的web攻击技术？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#6ajax是什么ajax的交互原理同步和异步的区别&quot;&gt;6.ajax是什么？ajax的交互原理？同步和异步的区别？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#4什么叫优雅降级和渐进增强&quot;&gt;4.什么叫优雅降级和渐进增强？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#5在javascript中什么是伪数组如何将伪数组转化为标准数组&quot;&gt;5.在JavaScript中什么是伪数组？如何将伪数组转化为标准数组？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#6浏览器本地储存&quot;&gt;6.浏览器本地储存？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#7线程和进程的区别&quot;&gt;7.线程和进程的区别？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#8请说出三种减少页面加载时间的方法&quot;&gt;8.请说出三种减少页面加载时间的方法？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#9http状态码&quot;&gt;9.HTTP状态码？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#10请解释javascript的同源策略&quot;&gt;10.请解释JavaScript的同源策略？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#11get和post的区别何时使用post&quot;&gt;11.get和post的区别，何时使用post？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#12-对前端工程师这个职位是怎么样理解的&quot;&gt;12. 对前端工程师这个职位是怎么样理解的？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;
&lt;h4 id=&quot;1-什么是盒子模型？&quot;&gt;&lt;a href=&quot;#1-什么是盒子模型？&quot; class=&quot;headerlink&quot; title=&quot;1.什么是盒子模型？&quot;&gt;&lt;/a&gt;1.什么是盒子模型？&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;两种&lt;/strong&gt;：IE盒子模型、标准W3C盒子模型，包括content、padding、margin、border。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;IE8的width=border-left+padding-left+内容宽度+padding-right+border-right;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;IE8的height=border-top+padding-top+内容高度+padding-bottom+border-bottom; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;w3c规定的width=内容宽度; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;w3c规定的height=内容高度;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这样有可能导致不同浏览器下获取的width或height的值不同,幸好jquery提供了另外两个方法:
    
    </summary>
    
      <category term="腾讯训练营" scheme="https://wtlemoney.github.io/categories/%E8%85%BE%E8%AE%AF%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
      <category term="面试" scheme="https://wtlemoney.github.io/categories/%E8%85%BE%E8%AE%AF%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="总结" scheme="https://wtlemoney.github.io/categories/%E8%85%BE%E8%AE%AF%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%9D%A2%E8%AF%95/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="blogs" scheme="https://wtlemoney.github.io/tags/blogs/"/>
    
      <category term="interview" scheme="https://wtlemoney.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>那些你常常会忘的处理数组的函数</title>
    <link href="https://wtlemoney.github.io/2018/04/02/%E6%95%B0%E7%BB%84/"/>
    <id>https://wtlemoney.github.io/2018/04/02/数组/</id>
    <published>2018-04-01T16:38:49.000Z</published>
    <updated>2018-04-07T08:40:55.283Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;哈哈，看似是些简单的处理数组的函数，但是由于平时码的少，实习生笔试的时候走了弯路吃了亏啊，写的很慢呀。。。有些是忘记了，有些是参数和返回值记忆模糊了，所以多码码，总结总结。持续更新中…</p><!-- toc --><ul><li><a href="#1-splice">1. splice()</a></li><li><a href="#2-slice">2. slice()</a></li><li><a href="#3-filter">3. filter()</a></li><li><a href="#4-map">4. map()</a></li><li><a href="#5-reduce">5. reduce()</a></li><li><a href="#6-every">6. every()</a></li><li><a href="#7-some">7. some()</a></li></ul><!-- tocstop --><h4><span id="1-splice">1. splice()</span></h4><p>返回值为被删除的元素数组，原数组会改变<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="string">'a'</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="string">'d'</span>];</span><br><span class="line">arr.splice(<span class="number">1</span>,<span class="number">2</span>,<span class="string">'b'</span>,<span class="string">'c'</span>);<span class="comment">//[4,5]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//["a", "b", "c", "d"]</span></span><br></pre></td></tr></table></figure></p><h4><span id="2-slice">2. slice()</span></h4><p>可从已有的数组中返回选定的元素,并不会修改数组。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>];</span><br><span class="line">arr.slice(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//['a','c','d']</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//["a", "b", "c", "d"]</span></span><br></pre></td></tr></table></figure></p><a id="more"></a>    <h4><span id="3-filter">3. filter()</span></h4><p>返回新的数组,原数组不改变<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBigEnough</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value&gt;=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr=[<span class="number">12</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">130</span>,<span class="number">44</span>];</span><br><span class="line">arr.filter(isBigEnough);<span class="comment">//[12,130,44]</span></span><br></pre></td></tr></table></figure></p><h4><span id="4-map">4. map()</span></h4><p>生成新的数组<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res=arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x*x;</span><br><span class="line">&#125;);<span class="comment">//res=[1,4,9]</span></span><br></pre></td></tr></table></figure></p><h4><span id="5-reduce">5. reduce()</span></h4><p>原数组不改变<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> res=arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;);<span class="comment">//res=15</span></span><br></pre></td></tr></table></figure></p><h4><span id="6-every">6. every()</span></h4><p>判断arr是否都满足x&gt;=18的条件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">12</span>,<span class="number">34</span>,<span class="number">56</span>];</span><br><span class="line"><span class="keyword">var</span> res=arr.every(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&gt;=<span class="number">18</span>;</span><br><span class="line">&#125;);<span class="comment">//false</span></span><br></pre></td></tr></table></figure></p><h4><span id="7-some">7. some()</span></h4><p>判断是否有满足条件的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">12</span>,<span class="number">34</span>,<span class="number">56</span>];</span><br><span class="line"><span class="keyword">var</span> res=arr.some(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&gt;=<span class="number">18</span>;</span><br><span class="line">&#125;);<span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;哈哈，看似是些简单的处理数组的函数，但是由于平时码的少，实习生笔试的时候走了弯路吃了亏啊，写的很慢呀。。。有些是忘记了，有些是参数和返回值记忆模糊了，所以多码码，总结总结。持续更新中…&lt;/p&gt;
&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-splice&quot;&gt;1. splice()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-slice&quot;&gt;2. slice()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3-filter&quot;&gt;3. filter()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#4-map&quot;&gt;4. map()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#5-reduce&quot;&gt;5. reduce()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#6-every&quot;&gt;6. every()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#7-some&quot;&gt;7. some()&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;
&lt;h4 id=&quot;1-splice&quot;&gt;&lt;a href=&quot;#1-splice&quot; class=&quot;headerlink&quot; title=&quot;1. splice()&quot;&gt;&lt;/a&gt;1. splice()&lt;/h4&gt;&lt;p&gt;返回值为被删除的元素数组，原数组会改变&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; arr=[&lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;d&#39;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;arr.splice(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;b&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;c&#39;&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//[4,5]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(arr);&lt;span class=&quot;comment&quot;&gt;//[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;2-slice&quot;&gt;&lt;a href=&quot;#2-slice&quot; class=&quot;headerlink&quot; title=&quot;2. slice()&quot;&gt;&lt;/a&gt;2. slice()&lt;/h4&gt;&lt;p&gt;可从已有的数组中返回选定的元素,并不会修改数组。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; arr=[&lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;b&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;c&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;d&#39;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;arr.slice(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//[&#39;a&#39;,&#39;c&#39;,&#39;d&#39;]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(arr);&lt;span class=&quot;comment&quot;&gt;//[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数组" scheme="https://wtlemoney.github.io/categories/%E6%95%B0%E7%BB%84/"/>
    
      <category term="函数" scheme="https://wtlemoney.github.io/categories/%E6%95%B0%E7%BB%84/%E5%87%BD%E6%95%B0/"/>
    
    
      <category term="blogs" scheme="https://wtlemoney.github.io/tags/blogs/"/>
    
      <category term="JavaScript" scheme="https://wtlemoney.github.io/tags/JavaScript/"/>
    
      <category term="array" scheme="https://wtlemoney.github.io/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>作用域闭包</title>
    <link href="https://wtlemoney.github.io/2018/03/30/%E9%97%AD%E5%8C%85/"/>
    <id>https://wtlemoney.github.io/2018/03/30/闭包/</id>
    <published>2018-03-30T12:48:11.000Z</published>
    <updated>2018-04-07T08:42:27.083Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#1-什么是闭包">1. 什么是闭包？</a></li><li><a href="#2-循环和闭包">2. 循环和闭包</a></li><li><a href="#3-闭包的好处">3. 闭包的好处</a><ul><li><a href="#31-减少局部变量">3.1 减少局部变量</a></li><li><a href="#32-减少传递给函数的参数变量">3.2 减少传递给函数的参数变量</a></li><li><a href="#33-封装">3.3 封装</a></li></ul></li></ul><!-- tocstop --><h4><span id="1-什么是闭包">1. 什么是闭包？</span></h4><p>&emsp;&emsp;OK,来看下面一段能清晰展示闭包的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> a=<span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> baz=foo();</span><br><span class="line">baz();<span class="comment">//2</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;闭包使得函数bar()可以继续访问定义时的词法作用域。函数能被外部调用到，则该作用域链上的所有变量都会被保存下来。  </p><blockquote><ul><li>定义：包就是能够读取其他函数内部变量的函数。由于在JavaScript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解为“定义在一个函数内部的函数”。</li><li>本质：闭包是将函数内部和外部连接起来的桥梁。</li><li>用处：一是可以读取函数内部的变量；二是让这些变量的值始终保持在内存中。</li><li>注意点：<a id="more"></a><br>&emsp;&emsp;&emsp;1）不能滥用闭包<br>&emsp;&emsp;由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能会导致内存泄漏。<br>&emsp;&emsp;解决方法：在退出函数之前，将不使用的局部变量全部删除。<br>&emsp;&emsp;&emsp;2）不要随便改变父函数内部变量的值。<br>&emsp;&emsp;把父函数当作对象使用，闭包当作它的公有方法，内部变量当作它的私有属性，闭包会在父函数外部，改变父函数变量的值，所以要注意。  </li></ul></blockquote><h4><span id="2-循环和闭包">2. 循环和闭包</span></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;,i*<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;正常情况下，这段代码预期会分别输出数字1-5，每秒一次，每次一个(注意是i*1000,不是1000)。但实际上，这段代码会以每秒一次的频率输出五次6(如果是1000，五个6会同一时间输出)！这是因为：循环的终止条件是i=6，而延迟函数的回调会在循坏结束时在执行。<br>&emsp;&emsp;试一下这样可以输出预期的1-5吗：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">      (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(i);</span><br><span class="line">      &#125;,i*<span class="number">1000</span>);</span><br><span class="line">&#125;)();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;答案是不行！这样每个延迟函数确实将立即执行函数在每次迭代中创建的作用域封闭起来，但是作用域是空的，所以它需要有自己的变量，用来在迭代中储存i的值。像下面这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">      (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> j=i;</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(j);</span><br><span class="line">      &#125;,j*<span class="number">1000</span>);</span><br><span class="line">&#125;)();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;可以对上面的代码进行改进：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">      (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>)</span>&#123;<span class="comment">//将i传递进来，将变量名定为j，当然也可以还叫作i</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(j);</span><br><span class="line">      &#125;,j*<span class="number">1000</span>);</span><br><span class="line">&#125;)(i);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;块作用域和闭包联手，听说天下无敌，不信你看：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(j);</span><br><span class="line">   &#125;,j*<span class="number">1000</span>);<span class="comment">//程序员的快乐</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4><span id="3-闭包的好处">3. 闭包的好处</span></h4><h5><span id="31-减少局部变量">3.1 减少局部变量</span></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;a++;alert(a);&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result=f();</span><br><span class="line">result();<span class="comment">//1</span></span><br><span class="line">result();<span class="comment">//2</span></span><br></pre></td></tr></table></figure><h5><span id="32-减少传递给函数的参数变量">3.2 减少传递给函数的参数变量</span></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calFactory</span>(<span class="params">base</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">max</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> total=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=max;i++)&#123;</span><br><span class="line">            total+=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total+base;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> adder=calFactory(<span class="number">2</span>);</span><br><span class="line">adder(<span class="number">3</span>);<span class="comment">//8</span></span><br></pre></td></tr></table></figure><h5><span id="33-封装">3.3 封装</span></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> m=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getM</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> m;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setM</span>(<span class="params">val</span>)</span>&#123;m=val;&#125;</span><br><span class="line">    <span class="built_in">window</span>.g=getM;</span><br><span class="line">    <span class="built_in">window</span>.f=setM;</span><br><span class="line">&#125;)();</span><br><span class="line">f(<span class="number">12</span>);</span><br><span class="line">alert(g());<span class="comment">//12</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-什么是闭包&quot;&gt;1. 什么是闭包？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-循环和闭包&quot;&gt;2. 循环和闭包&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3-闭包的好处&quot;&gt;3. 闭包的好处&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#31-减少局部变量&quot;&gt;3.1 减少局部变量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#32-减少传递给函数的参数变量&quot;&gt;3.2 减少传递给函数的参数变量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#33-封装&quot;&gt;3.3 封装&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;
&lt;h4 id=&quot;1-什么是闭包？&quot;&gt;&lt;a href=&quot;#1-什么是闭包？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是闭包？&quot;&gt;&lt;/a&gt;1. 什么是闭包？&lt;/h4&gt;&lt;p&gt;&amp;emsp;&amp;emsp;OK,来看下面一段能清晰展示闭包的代码：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a=&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;bar&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(a);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; bar;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; baz=foo();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;baz();&lt;span class=&quot;comment&quot;&gt;//2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;闭包使得函数bar()可以继续访问定义时的词法作用域。函数能被外部调用到，则该作用域链上的所有变量都会被保存下来。  &lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;定义：包就是能够读取其他函数内部变量的函数。由于在JavaScript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解为“定义在一个函数内部的函数”。&lt;/li&gt;
&lt;li&gt;本质：闭包是将函数内部和外部连接起来的桥梁。&lt;/li&gt;
&lt;li&gt;用处：一是可以读取函数内部的变量；二是让这些变量的值始终保持在内存中。&lt;/li&gt;
&lt;li&gt;注意点：
    
    </summary>
    
      <category term="闭包" scheme="https://wtlemoney.github.io/categories/%E9%97%AD%E5%8C%85/"/>
    
      <category term="你不知道的JavaScript" scheme="https://wtlemoney.github.io/categories/%E9%97%AD%E5%8C%85/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript/"/>
    
    
      <category term="blogs" scheme="https://wtlemoney.github.io/tags/blogs/"/>
    
      <category term="JavaScript" scheme="https://wtlemoney.github.io/tags/JavaScript/"/>
    
      <category term="闭包" scheme="https://wtlemoney.github.io/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>变量提升</title>
    <link href="https://wtlemoney.github.io/2018/03/29/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/"/>
    <id>https://wtlemoney.github.io/2018/03/29/变量提升/</id>
    <published>2018-03-28T16:25:38.000Z</published>
    <updated>2018-04-07T08:40:49.934Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#1-先有鸡还是先有蛋">1. 先有鸡还是先有蛋</a></li><li><a href="#2-函数优先">2. 函数优先</a></li></ul><!-- tocstop --><h4><span id="1-先有鸡还是先有蛋">1. 先有鸡还是先有蛋</span></h4><p>&emsp;&emsp;来看下面两段代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//2</span></span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="keyword">var</span> a=<span class="number">2</span>;<span class="comment">//undefined,不是ReferenceError!</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;实际上，包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。所以，先有蛋（声明）后有鸡（赋值）。只有声明本身会提升，而赋值或其他运行逻辑会留在原地。<br><br>&emsp;&emsp;注意：函数声明会被提升，但是函数表达式不会提升。看下面：<a id="more"></a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);<span class="comment">//undefined</span></span><br><span class="line">    <span class="keyword">var</span> a=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo();<span class="comment">//不是ReferenceError,而是TypeError!</span></span><br><span class="line"><span class="keyword">var</span> foo=<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;foo()由于对undefined值进行函数调用而导致非法操作，因此抛出TypeError异常！</p><h4><span id="2-函数优先">2. 函数优先</span></h4><p>&emsp;&emsp;有多个“重复”声明的代码中，函数首先被提升，然后才是变量：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">foo();<span class="comment">//1</span></span><br><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;会输出1而不是2！这个代码会被引擎理解为如下形式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();<span class="comment">//1</span></span><br><span class="line">foo=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;所以，要避免重复声明，特别是当普通的var声明和函数声明混合在一起的时候，否则会引起很多危险的问题！<br>&emsp;&emsp;尽管重复的var声明会被会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">foo();<span class="comment">//3</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;需要注意的是，尽可能避免在块内部声明函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">foo();<span class="comment">//'b'</span></span><br><span class="line"><span class="keyword">var</span> a=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(a)&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"a"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"a"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-先有鸡还是先有蛋&quot;&gt;1. 先有鸡还是先有蛋&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-函数优先&quot;&gt;2. 函数优先&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;
&lt;h4 id=&quot;1-先有鸡还是先有蛋&quot;&gt;&lt;a href=&quot;#1-先有鸡还是先有蛋&quot; class=&quot;headerlink&quot; title=&quot;1. 先有鸡还是先有蛋&quot;&gt;&lt;/a&gt;1. 先有鸡还是先有蛋&lt;/h4&gt;&lt;p&gt;&amp;emsp;&amp;emsp;来看下面两段代码&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;a=&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(a);&lt;span class=&quot;comment&quot;&gt;//2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(a);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a=&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//undefined,不是ReferenceError!&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;实际上，包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。所以，先有蛋（声明）后有鸡（赋值）。只有声明本身会提升，而赋值或其他运行逻辑会留在原地。&lt;br&gt;&lt;br&gt;&amp;emsp;&amp;emsp;注意：函数声明会被提升，但是函数表达式不会提升。看下面：
    
    </summary>
    
      <category term="你不知道的JavaScript" scheme="https://wtlemoney.github.io/categories/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript/"/>
    
      <category term="函数" scheme="https://wtlemoney.github.io/categories/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript/%E5%87%BD%E6%95%B0/"/>
    
    
      <category term="blogs" scheme="https://wtlemoney.github.io/tags/blogs/"/>
    
      <category term="JavaScript" scheme="https://wtlemoney.github.io/tags/JavaScript/"/>
    
      <category term="变量" scheme="https://wtlemoney.github.io/tags/%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>this的指向问题</title>
    <link href="https://wtlemoney.github.io/2018/03/27/this%E7%9A%84%E6%8C%87%E5%90%91/"/>
    <id>https://wtlemoney.github.io/2018/03/27/this的指向/</id>
    <published>2018-03-27T11:06:24.000Z</published>
    <updated>2018-04-07T08:45:49.957Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#1-this的绑定规则">1. this的绑定规则</a><ul><li><a href="#11-默认绑定">1.1 默认绑定</a></li><li><a href="#12-隐式绑定">1.2 隐式绑定</a><ul><li><a href="#121-隐式丢失常见">1.2.1 隐式丢失（常见）</a></li><li><a href="#122-隐式丢失传入回调函数时">1.2.2 隐式丢失（传入回调函数时）</a></li></ul></li><li><a href="#13显示绑定">1.3显示绑定</a><ul><li><a href="#131-硬绑定">1.3.1 硬绑定</a></li><li><a href="#132-api调用的上下文">1.3.2 API调用的上下文</a></li></ul></li><li><a href="#14-new绑定">1.4 new绑定</a></li></ul></li><li><a href="#2-回调函数里的this常见">2. 回调函数里的this（常见）</a><ul><li><a href="#21-箭头函数的另一个经典例子">2.1 箭头函数的另一个经典例子</a></li></ul></li></ul><!-- tocstop --><h4><span id="1-this的绑定规则">1. this的绑定规则</span></h4><h5><span id="11-默认绑定">1.1 默认绑定</span></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a=<span class="number">2</span>;</span><br><span class="line">foo();<span class="comment">//2</span></span><br></pre></td></tr></table></figure><h5><span id="12-隐式绑定">1.2 隐式绑定</span></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1=&#123;</span><br><span class="line">    a:<span class="number">2</span>,</span><br><span class="line">    foo:foo,</span><br><span class="line">    obj2:obj2</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2=&#123;</span><br><span class="line">    a:<span class="number">42</span>,</span><br><span class="line">    foo:foo</span><br><span class="line">&#125;;</span><br><span class="line">obj1.foo();<span class="comment">//2</span></span><br><span class="line">obj1.obj2.foo();<span class="comment">//42</span></span><br></pre></td></tr></table></figure><a id="more"></a><h6><span id="121-隐式丢失常见">1.2.1 隐式丢失（常见）</span></h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    a:<span class="number">2</span>,</span><br><span class="line">    foo:foo</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar =obj.foo;<span class="comment">//函数别名！丢失绑定对象，会应用默认绑定</span></span><br><span class="line"><span class="keyword">var</span> a=<span class="string">"global"</span>;</span><br><span class="line">bar();<span class="comment">//"global"</span></span><br></pre></td></tr></table></figure><h6><span id="122-隐式丢失传入回调函数时">1.2.2 隐式丢失（传入回调函数时）</span></h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doFoo</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    fn();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    a:<span class="number">2</span>,</span><br><span class="line">    foo:foo</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a=<span class="string">"global"</span>;</span><br><span class="line">doFoo(obj.foo);<span class="comment">//"global",回掉函数丢失this绑定是非常常见的</span></span><br></pre></td></tr></table></figure><h5><span id="13显示绑定">1.3显示绑定</span></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    a:<span class="number">2</span>,</span><br><span class="line">    foo:foo</span><br><span class="line">&#125;;</span><br><span class="line">foo.call(obj);<span class="comment">//2,把this强制绑定到obj上，但还是无法解决隐式绑定中的绑定丢失</span></span><br></pre></td></tr></table></figure><h6><span id="131-硬绑定">1.3.1 硬绑定</span></h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    a:<span class="number">2</span>,</span><br><span class="line">    foo:foo</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    foo.call(obj);</span><br><span class="line">&#125;</span><br><span class="line">bar();<span class="comment">//2</span></span><br><span class="line">setTimeout(bar,<span class="number">100</span>);<span class="comment">//2</span></span><br><span class="line">bar.call(<span class="built_in">window</span>);<span class="comment">//2,硬绑定的bar不可能再修改它的this</span></span><br></pre></td></tr></table></figure><h6><span id="132-api调用的上下文">1.3.2 API调用的上下文</span></h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">el</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(el,<span class="keyword">this</span>.id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    id:<span class="string">"awesome"</span></span><br><span class="line">&#125;</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].forEach(foo,obj);<span class="comment">//第二个参数的obj,用来指定foo中this的指向</span></span><br><span class="line"> <span class="comment">//输出为：1 awesome 2 awesome 3 awesome</span></span><br></pre></td></tr></table></figure><h5><span id="14-new绑定">1.4 new绑定</span></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a=a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar =<span class="keyword">new</span> foo(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bar.a);</span><br></pre></td></tr></table></figure><p><br></p><blockquote><p>&emsp;&emsp;<br>&emsp;&emsp;四类绑定的优先级：new绑定&gt;显示绑定&gt;隐式绑定&gt;默认绑定<br><br></p></blockquote><h4><span id="2-回调函数里的this常见">2. 回调函数里的this（常见）</span></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    name:<span class="string">'wt'</span>,</span><br><span class="line">    foo1:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);<span class="comment">//Object&#123;name:'wt'&#125;</span></span><br><span class="line">        <span class="keyword">var</span> _this=<span class="keyword">this</span>;<span class="comment">//用_this保存this的指向</span></span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>);<span class="comment">//Window</span></span><br><span class="line">            <span class="built_in">console</span>.log(_this);<span class="comment">//Object&#123;name:'wt'&#125;</span></span><br><span class="line">        &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    foo2:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);<span class="comment">//Object&#123;name:'wt'&#125;</span></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>);<span class="comment">//Object&#123;name:'wt'&#125;</span></span><br><span class="line">        &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用1  </p><p>&emsp;&emsp;<code>obj.foo1();//结果见上面代码的注释</code></p><p>调用2  </p><p>&emsp;&emsp;<code>obj.foo2();</code><br>&emsp;&emsp;1,2两个方法同时调用的话，两个setTimeout会稍后执行，先执行foo1和foo2的<code>console.log(this)</code>,打印顺序不一样。这里的foo2相当于：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo2:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="keyword">this</span>)&#125;.bind(<span class="keyword">this</span>),<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用3</p><p><code>var f=obj.foo1;//或f=obj.foo2</code><br><code>f();//this全部指向Window</code></p><h5><span id="21-箭头函数的另一个经典例子">2.1 箭头函数的另一个经典例子</span></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span><span class="function">(<span class="params">a</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);<span class="comment">//this继承自foo</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1=&#123;</span><br><span class="line">    a:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2=&#123;</span><br><span class="line">    a:<span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar=foo.call(obj1);</span><br><span class="line">bar.call(obj2);<span class="comment">//2,不是3！</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-this的绑定规则&quot;&gt;1. this的绑定规则&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#11-默认绑定&quot;&gt;1.1 默认绑定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#12-隐式绑定&quot;&gt;1.2 隐式绑定&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#121-隐式丢失常见&quot;&gt;1.2.1 隐式丢失（常见）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#122-隐式丢失传入回调函数时&quot;&gt;1.2.2 隐式丢失（传入回调函数时）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#13显示绑定&quot;&gt;1.3显示绑定&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#131-硬绑定&quot;&gt;1.3.1 硬绑定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#132-api调用的上下文&quot;&gt;1.3.2 API调用的上下文&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#14-new绑定&quot;&gt;1.4 new绑定&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-回调函数里的this常见&quot;&gt;2. 回调函数里的this（常见）&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#21-箭头函数的另一个经典例子&quot;&gt;2.1 箭头函数的另一个经典例子&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;
&lt;h4 id=&quot;1-this的绑定规则&quot;&gt;&lt;a href=&quot;#1-this的绑定规则&quot; class=&quot;headerlink&quot; title=&quot;1. this的绑定规则&quot;&gt;&lt;/a&gt;1. this的绑定规则&lt;/h4&gt;&lt;h5 id=&quot;1-1-默认绑定&quot;&gt;&lt;a href=&quot;#1-1-默认绑定&quot; class=&quot;headerlink&quot; title=&quot;1.1 默认绑定&quot;&gt;&lt;/a&gt;1.1 默认绑定&lt;/h5&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.a);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a=&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;foo();&lt;span class=&quot;comment&quot;&gt;//2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h5 id=&quot;1-2-隐式绑定&quot;&gt;&lt;a href=&quot;#1-2-隐式绑定&quot; class=&quot;headerlink&quot; title=&quot;1.2 隐式绑定&quot;&gt;&lt;/a&gt;1.2 隐式绑定&lt;/h5&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.a);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; obj1=&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    a:&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    foo:foo,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    obj2:obj2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; obj2=&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    a:&lt;span class=&quot;number&quot;&gt;42&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    foo:foo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;obj1.foo();&lt;span class=&quot;comment&quot;&gt;//2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;obj1.obj2.foo();&lt;span class=&quot;comment&quot;&gt;//42&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="你不知道的JavaScript" scheme="https://wtlemoney.github.io/categories/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript/"/>
    
    
      <category term="blogs" scheme="https://wtlemoney.github.io/tags/blogs/"/>
    
      <category term="JavaScript" scheme="https://wtlemoney.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>我为什么要写博客</title>
    <link href="https://wtlemoney.github.io/2018/03/25/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%86%99%E5%8D%9A%E5%AE%A2/"/>
    <id>https://wtlemoney.github.io/2018/03/25/我为什么写博客/</id>
    <published>2018-03-25T15:21:10.000Z</published>
    <updated>2018-04-16T01:41:07.195Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;首先，我是一个从零开始的前端自学者，断断续续学了几个月的时间，留下了3个要满的手写笔记本，几本重点画了又画的前端书籍，以及电脑上数不清的手敲代码的各类文件夹。通过很多网站看了很多前端知识，然而现在…几乎忘的差不多了。我发现一个事实，自己一直在“学”，没有好好的总结，更不用说“习”了。所以，为啥要搞博客这么高端大气上档次的东西咧，总结一下主要有下面几点原因：  </p><ul><li><strong>面试被血虐</strong> </li></ul><p>&emsp;&emsp;前两天的腾讯实习生面试加笔试，把我虐的一塌糊涂。尽管我知道我自己菜，但没想到面完之后感觉自己也太菜了吧。很多问题其实都是平时遇到过的，只不过自己没有独立思考过原理和本质，回答的太不顺利。所以想通过博客这一平台，总结自己学习的知识，来检验自己是否真的掌握了。<br><a id="more"></a></p><ul><li><strong>语言逻辑差</strong></li></ul><p>&emsp;&emsp; 很多以为自己懂了的知识点，其实在面试官面前说出来就变味道了。语言没有任何逻辑性。这样很不好啊，听的人很累的呀，希望能多提高一下语言表达能力。 </p><ul><li><strong>梳理总结知识</strong></li></ul><p>&emsp;&emsp;记了那么多的笔记，翻起来还是相当以及极其之困难的，基本上也没翻过，都是百度。所以趁机好好整理我的宝贝笔记，把精华全部放到我的博客上。可以方便自己“习”，能帮到其他学习前端的同学就再好不过了。  </p><ul><li><strong>提高写作能力</strong></li></ul><p>&emsp;&emsp;微信读书看过不少书，特别欣赏能写出一首好文章的人。我写作能力高中就菜，希望通过自己坚持写博客，提高一下自己的写作水平，毕竟妹子还是搞点文艺犯比较招人喜欢的吧。</p><p>&emsp;&emsp;我的心路历程就是这样子滴。你看吧，说话真的没啥逻辑可言。<br>&emsp;&emsp;希望自己多多总结，找个好工作！<br>&emsp;&emsp;送给自己一些字符串：  </p><p><center><font color="blue" size="3">“越努力越幸运”</font></center></p><p><center><font color="blue" size="3">“远离舒适区”</font></center></p><p><center><font color="blue" size="3">“不能丧”</font></center><br>&emsp;&emsp;此处应附上我的美丽自拍和心灵鸡汤：</p><div align="center"><br>    <img src="/2018/03/25/我为什么写博客/beauty.jpg" width="180" height="180" alt="我的自拍"><br></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;首先，我是一个从零开始的前端自学者，断断续续学了几个月的时间，留下了3个要满的手写笔记本，几本重点画了又画的前端书籍，以及电脑上数不清的手敲代码的各类文件夹。通过很多网站看了很多前端知识，然而现在…几乎忘的差不多了。我发现一个事实，自己一直在“学”，没有好好的总结，更不用说“习”了。所以，为啥要搞博客这么高端大气上档次的东西咧，总结一下主要有下面几点原因：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;面试被血虐&lt;/strong&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;前两天的腾讯实习生面试加笔试，把我虐的一塌糊涂。尽管我知道我自己菜，但没想到面完之后感觉自己也太菜了吧。很多问题其实都是平时遇到过的，只不过自己没有独立思考过原理和本质，回答的太不顺利。所以想通过博客这一平台，总结自己学习的知识，来检验自己是否真的掌握了。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="碎碎念" scheme="https://wtlemoney.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="blogs" scheme="https://wtlemoney.github.io/tags/blogs/"/>
    
      <category term="碎碎念" scheme="https://wtlemoney.github.io/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
</feed>
