<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wtLemoney</title>
  
  <subtitle>To be a happy&amp;lovely programmer...</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wtlemoney.github.io/"/>
  <updated>2018-05-06T12:46:14.742Z</updated>
  <id>https://wtlemoney.github.io/</id>
  
  <author>
    <name>wtLemoney</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HTML5指南（一）</title>
    <link href="https://wtlemoney.github.io/2018/05/06/HTML5-1/"/>
    <id>https://wtlemoney.github.io/2018/05/06/HTML5-1/</id>
    <published>2018-05-06T12:35:56.000Z</published>
    <updated>2018-05-06T12:46:14.742Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#1html5的目标和解决的问题">1.HTML5的目标和解决的问题</a></li><li><a href="#2html5主要的新特性">2.HTML5主要的新特性</a></li><li><a href="#3html5和html4的区别">3.HTML5和HTML4的区别</a><ul><li><a href="#31新增的元素和废弃的元素">3.1新增的元素和废弃的元素</a></li><li><a href="#32新增的属性和废弃的属性">3.2新增的属性和废弃的属性</a></li><li><a href="#33全局属性">3.3全局属性</a></li><li><a href="#34新增的事件">3.4新增的事件</a></li></ul></li></ul><!-- tocstop --><h3><span id="1html5的目标和解决的问题">1.HTML5的目标和解决的问题</span></h3><p><strong>目标：</strong>能够创建更简单的Web程序，书写出更简洁的HTML代码。</p><p><strong>解决的问题：</strong></p><ul><li>Web浏览器之间的兼容性很低。</li><li>文档结构不够明确。</li><li>Web应用程序的功能受到了限制。<a id="more"></a></li></ul><h3><span id="2html5主要的新特性">2.HTML5主要的新特性</span></h3><p><strong>语义特性：</strong>HTML5赋予网页更好的意义和结构。简单来说就是程序猿更方便跟浏览器沟通。</p><p><strong>本地存储特性：</strong>基于HTML5开发的网页APP拥有更短的启动时间，更快的联网速度，因为可以将一些常用、不常更新的内容存储在本地。</p><p><strong>设备兼容特性：</strong>HTML5提供了前所未有的数据与应用接入开放接口。使外部应用可以直接与浏览器内部的数据直接相连，例如视频影音可直接与microphones及摄像头相联。</p><p><strong>连接特性：</strong>HTML5拥有更有效的服务器推送技术，Server-SentEvent和WebSockets就是其中的两个特性，这两个特性能够帮助实现服务器将数据“推送”到客户端的功能。更有效的连接工作效率，可以实现基于页面的实时聊天，更快速的网页游戏体验，更优化的在线交流。</p><p><strong>网页多媒体特性：</strong>支持网页端的Audio、Video等多媒体功能。</p><p><strong>三维、图形及特效特性：</strong>基于SVG、Canvas、WebGL及CSS3的3D功能，视觉效果将大大增强，在线3D网游就是最典型的例子。</p><p><strong>性能与集成特性：</strong>HTML5会通过XMLHttpRequest2等技术，帮助Web应用和网站在多样化的环境中更快速的工作。最直观的就是加载会更快。</p><p><strong>CSS3特性：</strong>相对于旧的CSS版本，HTML5所支持的CSS3中提供了更多的风格和更强的效果，也提供了更高的灵活性和控制性。</p><h3><span id="3html5和html4的区别">3.HTML5和HTML4的区别</span></h3><h4><span id="31新增的元素和废弃的元素">3.1新增的元素和废弃的元素</span></h4><ul><li><strong>新增的结构元素：</strong>section、article、aside、header、footer、nav、figure、main</li></ul><p>figure元素表示一段独立的流内容，一般表示文档主体流内容中的一个独立单元。</p><ul><li><strong>新增的其他元素：</strong>video、audio、embed、mark、progress、meter、time、canvas、command、datalist、datagrid、kengen、output、source、menu、dialog</li></ul><p>kengen元素表示生产秘钥。<br>meter元素表示度量衡，仅用于已知最大值和最小值的度量。</p><ul><li><p><strong>新增的input元素的类型：</strong>email、url、number、range、Date Pickers(date,month,week,time,datetime,datetime-local)</p></li><li><p><strong>被废除的元素：</strong></p><ul><li>能使用CSS替代的元素：basefont、big、center、font、s、strike、tt、u</li><li>不再使用frame框架：frameset、frame、noframes。由于frame框架对网页可用性存在负面影响，在HTML5中只支持iframe框架</li><li>只有部分浏览器支持的元素：applet、bgsound、blink、marquee</li><li>其他被废弃的元素：rb、acronym、dir、isindex、listing、xmp、nextid、plaintext</li></ul></li></ul><h4><span id="32新增的属性和废弃的属性">3.2新增的属性和废弃的属性</span></h4><ul><li><p><strong>新增表单相关的属性</strong></p><ul><li>autofocus (元素input[type=”tetx”],select,textarea,button)</li><li>placeholder（元素inout[type=”tetx”],textarea）</li><li>form() （元素input,output,select,textarea,button,fieldset）</li><li>required（元素inout[type=”tetx”],textarea）</li><li>autocomplete,min,max,multiple,pattern,step<br>新的list元素与datalist元素配合使用。datalist元素与autocomplete属性配合使用。<br>multiple属性允许在上传文件时一次上传多个文件。</li><li>formaction、formenctype、formmethod、formnovalidate、formtarget (元素input,button)<br>为fieldset元素增加了disabled属性。</li><li>novalidate (元素input,button,form)</li><li>labels,属性值为一个NodeList对象</li><li>可以在标签（lable元素）内部放置一个表单元素，并且通过该标签的control属性访问该表单元素。</li><li>SelectionDirection (元素input,textarea)</li><li>indeterminate (元素checkbox)</li><li>对类型为image的input元素添加width和height属性指定图片按钮宽高</li><li>maxlength和wrap(元素textarea)</li></ul></li><li><p><strong>链接相关的属性</strong></p><ul><li>media,download,ping （元素a和area）</li><li>hreflang,rel （元素area）</li><li>sizes (元素link)</li><li>target (元素base)</li></ul></li><li><p><strong>其他新增属性</strong></p><ul><li>start，reversed (元素ol)</li><li>charset (元素meta)</li><li>type，label（元素menu）</li><li>scoped （元素style）</li><li>async （元素script）</li><li>manifest （元素html）</li><li>sandbox,seamless,srcdoc（元素iframe）</li></ul></li><li><p><strong>废弃的元素</strong>（只列举部分HTML4常见的）</p><ul><li>charset (元素link,a)</li><li>target (元素link)</li><li>align (元素caption,input,div,h1-h6,p)</li><li>background，bgcolor （元素body）</li><li>align,bgcolor,border,cellpadding,cellspacing,frame,rules,width (元素table)</li><li>等等</li></ul></li></ul><h4><span id="33全局属性">3.3全局属性</span></h4><ul><li><strong>contentEditable：</strong>为true时，该元素变成可编辑的了</li><li><strong>designMode：</strong>on或off，指定整个页面是否可编辑</li><li><strong>hidden</strong></li><li><strong>spellcheck：</strong>true或false，不可缺省。 (针对元素input[input=text],textarea),功能是对用户输入的文本内容进行拼写和语法检查</li><li><strong>tableindex：</strong>设为负数，通常为-1，按下TAB键该元素就不能获得焦点。</li></ul><h4><span id="34新增的事件">3.4新增的事件</span></h4><ul><li><strong>window对象body元素：</strong>beforeprint,afterprint,resize,error,offline,online,pageshow,beforeunload,hashchange</li><li><strong>任何元素：</strong>mousewheel(当用户鼠标指针悬停在元素上并滚动鼠标时触发)</li><li><strong>任何容器元素：</strong>scoll</li><li><strong>input和textarea元素</strong>：input<br><code>&lt;input type=text oninput=&quot;alert(&quot;元素内容被修改&quot;)&quot;&gt;</code><br>当用户修改文本框内容时触发input事件，input事件和change事件的区别是input事件在元素尚未失去焦点时已触发，change事件只在元素失去焦点时触发</li><li><strong>form元素：</strong>reset</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1html5的目标和解决的问题&quot;&gt;1.HTML5的目标和解决的问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2html5主要的新特性&quot;&gt;2.HTML5主要的新特性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3html5和html4的区别&quot;&gt;3.HTML5和HTML4的区别&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#31新增的元素和废弃的元素&quot;&gt;3.1新增的元素和废弃的元素&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#32新增的属性和废弃的属性&quot;&gt;3.2新增的属性和废弃的属性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#33全局属性&quot;&gt;3.3全局属性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#34新增的事件&quot;&gt;3.4新增的事件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;
&lt;h3 id=&quot;1-HTML5的目标和解决的问题&quot;&gt;&lt;a href=&quot;#1-HTML5的目标和解决的问题&quot; class=&quot;headerlink&quot; title=&quot;1.HTML5的目标和解决的问题&quot;&gt;&lt;/a&gt;1.HTML5的目标和解决的问题&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;目标：&lt;/strong&gt;能够创建更简单的Web程序，书写出更简洁的HTML代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决的问题：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Web浏览器之间的兼容性很低。&lt;/li&gt;
&lt;li&gt;文档结构不够明确。&lt;/li&gt;
&lt;li&gt;Web应用程序的功能受到了限制。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="HTML5" scheme="https://wtlemoney.github.io/categories/HTML5/"/>
    
      <category term="HTML4" scheme="https://wtlemoney.github.io/categories/HTML5/HTML4/"/>
    
      <category term="表单" scheme="https://wtlemoney.github.io/categories/HTML5/HTML4/%E8%A1%A8%E5%8D%95/"/>
    
      <category term="事件" scheme="https://wtlemoney.github.io/categories/HTML5/HTML4/%E8%A1%A8%E5%8D%95/%E4%BA%8B%E4%BB%B6/"/>
    
    
      <category term="HTML5" scheme="https://wtlemoney.github.io/tags/HTML5/"/>
    
      <category term="HTML4" scheme="https://wtlemoney.github.io/tags/HTML4/"/>
    
      <category term="表单" scheme="https://wtlemoney.github.io/tags/%E8%A1%A8%E5%8D%95/"/>
    
      <category term="事件" scheme="https://wtlemoney.github.io/tags/%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Canvas常用API总结——HTML5</title>
    <link href="https://wtlemoney.github.io/2018/05/02/Canvas%E5%B8%B8%E7%94%A8API/"/>
    <id>https://wtlemoney.github.io/2018/05/02/Canvas常用API/</id>
    <published>2018-05-02T14:50:56.000Z</published>
    <updated>2018-05-06T09:37:29.876Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#1绘制线条">1.绘制线条</a></li><li><a href="#2线条样式">2.线条样式</a></li><li><a href="#3绘制曲线">3.绘制曲线</a></li><li><a href="#4绘制矩形及填充">4.绘制矩形及填充</a></li><li><a href="#5绘制阴影">5.绘制阴影</a></li><li><a href="#6绘制渐变">6.绘制渐变</a></li><li><a href="#7填充背景">7.填充背景</a></li><li><a href="#8变换">8.变换</a></li><li><a href="#9其他相关api">9.其他相关API</a></li></ul><!-- tocstop --><a id="more"></a><p>绘画的时候canvas相当于画布，而context相当于画笔。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;canvas id=<span class="string">"drawing"</span> width=<span class="string">"200"</span> height=<span class="string">"200"</span>&gt;Your browser doesn<span class="string">'t support the canvas tag.&lt;/canvas&gt;</span></span><br><span class="line"><span class="string">//js</span></span><br><span class="line"><span class="string">var draw=document.getElementById("drawing");</span></span><br><span class="line"><span class="string">var context=draw.getContext("2d");</span></span><br></pre></td></tr></table></figure></p><h4><span id="1绘制线条">1.绘制线条</span></h4><ul><li><p>moveTo(x0,y0)：把当前画笔（draw）移动到（x0,y0）这个位置。</p></li><li><p>lineTo(x1,y1):从当前位置(x0,y0)处到（x1，y1）画一条直线。</p></li><li><p>beginPath()：开启一条路径或者重置当前路径。</p></li><li><p>closePath():从当前点回到路径起始点，也就是上一个beginPath的位置。</p></li><li><p>stroke():绘制。必须加了这个函数才会画图，所以这个一定要放在最后。</p></li></ul><p>注意：closePath()放在stroke函数后面，则不会绘制成一个闭合的线条，因为在闭合前，已经绘制了。beginPath()和closePath()可以不成对出现，closePath()是用来闭合终点和起始点画一条闭合路径的。</p><h4><span id="2线条样式">2.线条样式</span></h4><ul><li><p>lineCap：线条端点样式（butt，round，square）-(平头，圆头，方头)。</p></li><li><p>lineJoin：两线条相交时的拐点样式（round，bevel，mitr）-(圆交，斜交，斜接)。其中设置为miter时还可以通过miterLimet设置拐点交界处的最大长度。</p></li><li><p>lineWidth：线条宽度</p></li><li><p>strokeStyle： 线条颜色、渐变(定义好的渐变对象)、模式。 context.strokeStyle=”#333”;</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">context.beginPath();</span><br><span class="line">context.strokeStyle=<span class="string">"#0000ff"</span>;</span><br><span class="line">context.lineWidth=<span class="number">20</span>;</span><br><span class="line">context.lineCap=<span class="string">"round"</span>;</span><br><span class="line">context.moveTo(<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">context.lineTo(<span class="number">80</span>,<span class="number">80</span>);</span><br><span class="line">context.stroke();</span><br></pre></td></tr></table></figure><h4><span id="3绘制曲线">3.绘制曲线</span></h4><ul><li>arc(x,y,radius,startAngle,endAngle,anticlockwise):绘制曲线。radius是曲线半径，startAngle,endAngle开始角度和结束角度，用的是弧度(Math.PI/180)*角度值，anticlockwise绘制方向（false为顺时针）；</li></ul><h4><span id="4绘制矩形及填充">4.绘制矩形及填充</span></h4><ul><li><p>rect():创建矩形；</p></li><li><p>fillStyle:设置填充颜色，<code>context.fillStyle=&quot;#0000ff&quot;;</code></p></li><li><p>fillRect(x,y,width,height):绘制被填充的矩形，(x,y)起始点，width，height为矩形宽高</p></li><li><p>strokeRect()：绘制矩形线框</p></li><li><p>clearRect():清除掉矩形。</p></li></ul><h4><span id="5绘制阴影">5.绘制阴影</span></h4><ul><li><p>shadowColor：阴影颜色</p></li><li><p>shadowBlur:模糊级别</p></li><li><p>shadowOffsetX：阴影的水平距离</p></li><li><p>shadowOffsetY：阴影的垂直距离</p></li></ul><p>注意：要先设置阴影再画矩形</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">context.shadowBlur=<span class="number">20</span>;</span><br><span class="line">context.shadowColor=<span class="string">"#456"</span>;</span><br><span class="line">context.shadowOffsetX=<span class="number">-10</span>;</span><br><span class="line">context.shadowOffsetY=<span class="number">30</span>;<span class="comment">//先设置阴影再画矩形</span></span><br><span class="line">context.fillStyle=<span class="string">"#108997"</span>;</span><br><span class="line">context.fillRect(<span class="number">20</span>,<span class="number">20</span>,<span class="number">100</span>,<span class="number">80</span>);</span><br><span class="line">context.stroke();</span><br></pre></td></tr></table></figure><p><img src="/2018/05/02/Canvas常用API/shadow.png" alt="img"></p><h4><span id="6绘制渐变">6.绘制渐变</span></h4><ul><li><p>createLinearGradient(x1,y1,x2,y2):绘制线性渐变，(x1,y1)是渐变的起始点，（x2,y2）是渐变的终点，位置不同可以制作出垂直或者水平渐变。</p></li><li><p>createRadialGradient(x1,y1,r1,x2,y2,r2)：径向渐变，(x1,y1)是渐变的起始点圆心，r1是半径，（x2,y2）是渐变的终点，r2是结束点半径;</p></li><li><p>addColorStop(stop,color)来设置渐变过程，stop是0.0到1.0的值。（两种渐变都需要使用）</p></li></ul><h4><span id="7填充背景">7.填充背景</span></h4><ul><li>createPattern(image,”repeat|repeat-x|repeat-y|no-repeat”):image是一个图片对象，后面的参数是用来设定图片的重复方式。 </li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> image = <span class="built_in">document</span>.images[<span class="number">0</span>],</span><br><span class="line"><span class="keyword">var</span> pattern = context.createPattern(image, <span class="string">"repeat"</span>);</span><br><span class="line"></span><br><span class="line">context.fillStyle = pattern;</span><br><span class="line">context.fillRect(<span class="number">10</span>, <span class="number">10</span>, <span class="number">150</span>, <span class="number">150</span>);</span><br></pre></td></tr></table></figure><h4><span id="8变换">8.变换</span></h4><ul><li><p>rotate(angle):围绕原点旋转图像angle弧度</p></li><li><p>scale(scaleX,scaleY):缩放</p></li><li><p>translate(x,y）:将坐标原点移动到(x,y)</p></li></ul><h4><span id="9其他相关api">9.其他相关API</span></h4><ul><li><p>fill():填充当前路径。</p></li><li><p>clip():从画布中剪裁任意形状和尺寸的画布，之后所有的绘图都会被限制在剪裁的区域内。</p></li><li><p>isPointInPath():<code>context.isPointInPath(x,y)</code>判断这个点是否位于当前路径</p></li><li><p>清除画布方法：获取画布的宽高，<code>draw.height,draw.width</code>，然后使用clearRect();</p></li><li><p>修改画布的宽高：<code>draw.width=&#39;200&#39;，draw.width=&#39;300&#39;</code></p></li><li><p>globalAlpha:设置透明度，只能是0~1的数字，如果透明度不一样，在画第二幅之前重新设置即可。</p></li><li><p>toDataURL:<code>draw.toDataURL(type,encoderOptions)</code>，这个函数返回一个image的base64的URI，参数都是可选的，type可以设置图片类型如image/jpeg,image/webp，默认是image/png；encoderOptions是一个0~1的数字，用来设置image/jpeg,image/webp的图片质量，其他格式的type设置这个参数无效。</p></li><li><p>想操作外部的画布，使用save()函数保存。想要回到之前保存的设置，再使用restore()函数恢复，中间做的操作不会消失。可连续调用restore()，实现一级一级返回。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1绘制线条&quot;&gt;1.绘制线条&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2线条样式&quot;&gt;2.线条样式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3绘制曲线&quot;&gt;3.绘制曲线&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#4绘制矩形及填充&quot;&gt;4.绘制矩形及填充&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#5绘制阴影&quot;&gt;5.绘制阴影&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#6绘制渐变&quot;&gt;6.绘制渐变&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#7填充背景&quot;&gt;7.填充背景&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#8变换&quot;&gt;8.变换&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#9其他相关api&quot;&gt;9.其他相关API&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;
    
    </summary>
    
      <category term="HTML5" scheme="https://wtlemoney.github.io/categories/HTML5/"/>
    
      <category term="Canvas画布，API" scheme="https://wtlemoney.github.io/categories/HTML5/Canvas%E7%94%BB%E5%B8%83%EF%BC%8CAPI/"/>
    
      <category term="JavaScript" scheme="https://wtlemoney.github.io/categories/HTML5/Canvas%E7%94%BB%E5%B8%83%EF%BC%8CAPI/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://wtlemoney.github.io/tags/JavaScript/"/>
    
      <category term="Canvas" scheme="https://wtlemoney.github.io/tags/Canvas/"/>
    
      <category term="前端画图" scheme="https://wtlemoney.github.io/tags/%E5%89%8D%E7%AB%AF%E7%94%BB%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>DOM事件</title>
    <link href="https://wtlemoney.github.io/2018/04/24/DOM%E4%BA%8B%E4%BB%B6/"/>
    <id>https://wtlemoney.github.io/2018/04/24/DOM事件/</id>
    <published>2018-04-24T05:24:27.158Z</published>
    <updated>2018-04-24T05:36:22.563Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#1事件流">1.事件流</a></li><li><a href="#2事件处理程序">2.事件处理程序</a><ul><li><a href="#21-html事件处理程序">2.1 HTML事件处理程序</a></li><li><a href="#22-dom0级事件处理程序">2.2 DOM0级事件处理程序</a></li><li><a href="#23-dom2级事件处理程序">2.3 DOM2级事件处理程序</a></li><li><a href="#24-ie事件处理程序">2.4 IE事件处理程序</a></li><li><a href="#25-跨浏览器的事件处理程序">2.5 跨浏览器的事件处理程序</a></li></ul></li><li><a href="#3事件对象">3.事件对象</a><ul><li><a href="#31-dom中的事件对象">3.1 DOM中的事件对象</a></li><li><a href="#32-ie中的事件对象">3.2 IE中的事件对象</a></li><li><a href="#33-跨浏览器的事件对象">3.3 跨浏览器的事件对象</a></li></ul></li></ul><!-- tocstop --><a id="more"></a><h3><span id="1事件流">1.事件流</span></h3><ul><li>描述：从页面中接收事件的顺序。</li><li>方式：<ul><li>事件冒泡（IE事件流）</li><li>事件捕获（Netscape）</li><li>DOM事件流：事件捕获阶段、处于目标阶段、事件冒泡阶段</li></ul></li></ul><h3><span id="2事件处理程序">2.事件处理程序</span></h3><h4><span id="21-html事件处理程序">2.1 HTML事件处理程序</span></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  &lt;input type=<span class="string">"button"</span> value=<span class="string">"Click me"</span> onclick=<span class="string">"showMessage()"</span>/&gt;</span><br><span class="line"></span><br><span class="line">  &lt;input type=<span class="string">"button"</span> value=<span class="string">"Click me"</span> onclick=<span class="string">"alert(event.type)"</span>/&gt;<span class="comment">//输出:"click"</span></span><br><span class="line">  &lt;input type=<span class="string">"button"</span> value=<span class="string">"Click me"</span> onclick=<span class="string">"alert(this.value)"</span>/&gt;<span class="comment">//输出:"Click me",this.value也可以写成value</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//无需引用表单元素就能访问其他表单字段</span></span><br><span class="line">&lt;form method=<span class="string">"post"</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> name=<span class="string">"username"</span> value=<span class="string">""</span>/&gt;</span><br><span class="line">    &lt;input type=<span class="string">"button"</span> value=<span class="string">"hhh"</span> onclick=<span class="string">"alert(username.value)"</span>/&gt;</span><br><span class="line">&lt;<span class="regexp">/form&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;缺点：时差问题，用户可能会在HTML元素一出现就触发了事件，这时候事件尚不具备执行条件。HTML和Js代码紧密耦合，不方便更改代码。</p><h4><span id="22-dom0级事件处理程序">2.2 DOM0级事件处理程序</span></h4><p>我不喜欢多打字，直接上代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn=<span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.id);  <span class="comment">//"myBtn"</span></span><br><span class="line"></span><br><span class="line">btn.onclick=<span class="literal">null</span>;<span class="comment">//删除事件处理程序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="23-dom2级事件处理程序">2.3 DOM2级事件处理程序</span></h4><p>两个方法：<code>addEventListener()</code>和<code>removeEventListener()</code><br>参数：要处理的事件名，作为事件处理程序的函数，一个布尔值（true:捕获，false:冒泡）<br>好处：可以添加多个事件程序，按顺序触发<br>注意：移除时，传入的参数与添加函数处理程序使用的参数相同，匿名函数无法移除</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> btn=<span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line"> <span class="keyword">var</span> handler=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.id);</span><br><span class="line"> &#125;</span><br><span class="line"> btn.addEventListener(<span class="string">"click"</span>,handler,<span class="literal">false</span>);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"> btn.removeEventListener(<span class="string">"click"</span>,handler,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h4><span id="24-ie事件处理程序">2.4 IE事件处理程序</span></h4><p>两个方法：<code>attachEvent()</code>和<code>detachEvent()</code>，（只有冒泡）<br>参数：要处理的事件名，作为事件处理程序的函数（作用域：全局，this指向全局）<br>注意：第一个参数如<code>onclick</code>,非DOM的<code>click</code>。<br>好处：也可以添加多个事件处理程序，但是是<code>以添加的相反的顺序触发</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> btn=<span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line"> <span class="keyword">var</span> handler=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"haha"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> btn.attachEvent(<span class="string">"onclick"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     alert(<span class="keyword">this</span>==<span class="built_in">window</span>);<span class="comment">//true</span></span><br><span class="line"> &#125;)</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//删除</span></span><br><span class="line"> btn.attachEvent(<span class="string">"onclick"</span>,handler);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"> btn.detachEvent(<span class="string">"onclick"</span>,handler);</span><br></pre></td></tr></table></figure><h4><span id="25-跨浏览器的事件处理程序">2.5 跨浏览器的事件处理程序</span></h4><p>EventUtil对象：处理浏览器间的差异<br>方法：<code>addHandler()</code>和<code>removeHandler()</code><br>参数：要操作的元素、事件名称、事件处理程序函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil=&#123;</span><br><span class="line">    addHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (element.addEventListener)&#123;</span><br><span class="line">            element.addEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent)&#123;</span><br><span class="line">            element.attachEvent(<span class="string">"on"</span> + type, handler);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            element[<span class="string">"on"</span> + type] = handler;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    removeHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (element.removeEventListener)&#123;</span><br><span class="line">            element.removeEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.detachEvent)&#123;</span><br><span class="line">            element.detachEvent(<span class="string">"on"</span> + type, handler);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            element[<span class="string">"on"</span> + type] = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用法如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(btn,<span class="string">"click"</span>,handler);</span><br><span class="line"></span><br><span class="line">EventUtil.removeHandler(btn,<span class="string">"click"</span>,handler);</span><br></pre></td></tr></table></figure></p><h3><span id="3事件对象">3.事件对象</span></h3><h4><span id="31-dom中的事件对象">3.1 DOM中的事件对象</span></h4><p>event对象属性/方法：<code>type,target,eventPhase,preventDefault(),stopPropagation(),....</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//event对象</span></span><br><span class="line"> <span class="keyword">var</span> btn=<span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line"> btn.onclick=<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">     alert(event.type);<span class="comment">//"click"</span></span><br><span class="line"> &#125;</span><br><span class="line"> btn.addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">     alert(event.type);<span class="comment">//"click"</span></span><br><span class="line"> &#125;,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure></p><h4><span id="32-ie中的事件对象">3.2 IE中的事件对象</span></h4><p>注意：DOM0级方法添加事件时，要<code>event=window.event</code><br>方法：</p><ul><li><code>cancelBubble</code>:默认为false，true为取消事件冒泡</li><li><code>returnValue</code>:默认为true，false为取消默认行为</li><li><code>srcElement</code>:事件的目标</li><li><code>type</code>:被触发的事件类型</li><li>作用域：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//DOM0级，故window.event</span></span><br><span class="line">    alert(<span class="built_in">window</span>.event.srcElement === <span class="keyword">this</span>);      <span class="comment">//true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">btn.attachEvent(<span class="string">"onclick"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    alert(event.srcElement === <span class="keyword">this</span>);             <span class="comment">//false</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h4><span id="33-跨浏览器的事件对象">3.3 跨浏览器的事件对象</span></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Eventil=&#123;</span><br><span class="line">    getEvent: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> event ? event : <span class="built_in">window</span>.event;</span><br><span class="line">    &#125;,</span><br><span class="line">    getTarget: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> event.target || event.srcElement;</span><br><span class="line">    &#125;,</span><br><span class="line">    preventDefault: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event.preventDefault)&#123;</span><br><span class="line">            event.preventDefault();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            event.returnValue = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    stopPropagation: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event.stopPropagation)&#123;</span><br><span class="line">            event.stopPropagation();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如取消冒泡：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"Clicked"</span>);</span><br><span class="line">    event = EventUtil.getEvent(event);</span><br><span class="line">    EventUtil.stopPropagation(event);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"Body clicked"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1事件流&quot;&gt;1.事件流&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2事件处理程序&quot;&gt;2.事件处理程序&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#21-html事件处理程序&quot;&gt;2.1 HTML事件处理程序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#22-dom0级事件处理程序&quot;&gt;2.2 DOM0级事件处理程序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#23-dom2级事件处理程序&quot;&gt;2.3 DOM2级事件处理程序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#24-ie事件处理程序&quot;&gt;2.4 IE事件处理程序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#25-跨浏览器的事件处理程序&quot;&gt;2.5 跨浏览器的事件处理程序&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3事件对象&quot;&gt;3.事件对象&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#31-dom中的事件对象&quot;&gt;3.1 DOM中的事件对象&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#32-ie中的事件对象&quot;&gt;3.2 IE中的事件对象&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#33-跨浏览器的事件对象&quot;&gt;3.3 跨浏览器的事件对象&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;
    
    </summary>
    
      <category term="DOM操作" scheme="https://wtlemoney.github.io/categories/DOM%E6%93%8D%E4%BD%9C/"/>
    
      <category term="事件处理" scheme="https://wtlemoney.github.io/categories/DOM%E6%93%8D%E4%BD%9C/%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/"/>
    
      <category term="DOM选择器" scheme="https://wtlemoney.github.io/categories/DOM%E6%93%8D%E4%BD%9C/%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/DOM%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    
    
      <category term="JavaScript" scheme="https://wtlemoney.github.io/tags/JavaScript/"/>
    
      <category term="DOM" scheme="https://wtlemoney.github.io/tags/DOM/"/>
    
      <category term="节点操作" scheme="https://wtlemoney.github.io/tags/%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C/"/>
    
      <category term="浏览器兼容" scheme="https://wtlemoney.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9/"/>
    
  </entry>
  
  <entry>
    <title>DOM基础知识梳理</title>
    <link href="https://wtlemoney.github.io/2018/04/22/DOM%E5%9F%BA%E7%A1%80/"/>
    <id>https://wtlemoney.github.io/2018/04/22/DOM基础/</id>
    <published>2018-04-22T04:27:39.000Z</published>
    <updated>2018-04-24T05:30:34.046Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;最近自己写项目的时候，DOM操作稍多，但是发现自己不是很熟悉，以前看过的知识不常用就忘了，用的时候也是要经常去官网或网上查找。所以想把DOM的知识点重新回顾一下，以下知识点来自“JavaScript高级程序设计”第10、11、12章节。另外，想自己练习DOM操作相关的题，推荐<a href="http://ife.baidu.com/college/detail/id/10" target="_blank" rel="noopener">百度前端技术学院</a>的斌斌学院，上面有很多可操作的题，看的再多不如自己多思考多敲代码，这点我深有体会，可是吃了大亏的啊。</p><!-- toc --><ul><li><a href="#1dom1">1.DOM1</a><ul><li><a href="#11node类型">1.1Node类型</a></li><li><a href="#12document类型">1.2Document类型</a></li><li><a href="#13element类型">1.3Element类型</a></li><li><a href="#14text类型">1.4Text类型</a></li></ul></li><li><a href="#2dom扩展">2.DOM扩展</a></li><li><a href="#3dom2和dom3">3.DOM2和DOM3</a></li></ul><!-- tocstop --><a id="more"></a><h3><span id="1dom1">1.DOM1</span></h3><p>1998年10月DOM1级规范成为W3C的推荐标准。</p><h4><span id="11node类型">1.1Node类型</span></h4><ul><li>除了IE，浏览器都可以访问这个类型</li><li>JS中的所有节点类型都继承自Node类型，所有的节点类型都共享着相同的基本属性和方法</li><li>someNode.nodeName保存标签名，someNode.nodeValue===null</li><li>每个节点都有一个nodeType属性，表示节点的类型（共12个数值常量）<br>&emsp;列举3个常用的节点类型数值常量：<br>&emsp;&emsp;&emsp;Node.ELEMENT_NODE(1)<br>&emsp;&emsp;&emsp;Node.ATTRIBUTE_NODE(2)<br>&emsp;&emsp;&emsp;Node.TEXT_NODE(3)<br>&emsp;用法：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(someNode.nodeType == Node.ELEMENT_NODE)&#123;<span class="comment">//在IE中无效</span></span><br><span class="line">    alert(<span class="string">"Node is a an element."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(someNode.nodeType == <span class="number">1</span>)&#123;<span class="comment">//适用于所有浏览器</span></span><br><span class="line">    alert(<span class="string">"Node is a an element."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>访问子节点：方括号和item()都可以</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstChild = someNode.childNodes[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> secondChild = someNode.childNodes.item(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><ul><li>通过<code>previousSibling</code>和<code>nextSibling</code>访问相邻的兄弟节点 </li><li>插入节点：<code>appendChild(node)</code>和<code>insertBefore(node，参照节点)</code></li><li>替换节点：<code>replaceChild(node，要替换的节点)</code></li><li>移除节点：<code>removeChild(node)</code></li></ul><h4><span id="12document类型">1.2Document类型</span></h4><ul><li>documentElement属性、childNodes[0]、firstChild都指向<code>&lt;html&gt;</code>元素</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> html = <span class="built_in">document</span>.documentElement;<span class="comment">//取得对&lt;html&gt;的引用</span></span><br><span class="line">alert(html ===<span class="built_in">document</span>.childNodes[<span class="number">0</span>]);<span class="comment">//true</span></span><br><span class="line">alert(html === <span class="built_in">document</span>.firstChild);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><ul><li>body属性指向<code>&lt;body&gt;</code>元素</li><li>查找元素：<code>getElementById()</code>和<code>getElementsByTagName()</code><br>&emsp;如果页面中多个元素的ID值相同，<code>getElementById()</code>只返回第一次出现的元素</li><li>对<code>&lt;img src=&quot;..&quot; name=&quot;myImage&quot;&gt;</code>取得<img>元素，可以有几种方法：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> images = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"img"</span>);</span><br><span class="line"><span class="keyword">var</span> myImage = images.namedItem(<span class="string">"myImage"</span>);<span class="comment">//方法1</span></span><br><span class="line"><span class="keyword">var</span> myImage = images[<span class="string">"myImage"</span>];<span class="comment">//方法2</span></span><br></pre></td></tr></table></figure><ul><li><code>getElementsByName</code>返回指定name特性的所有元素，常被使用情况：单选按钮</li><li><strong>特殊集合</strong><br>&emsp;document.anchors：包含文档中所有带name特性的<code>&lt;a&gt;</code>元素<br>&emsp;document.forms：所有<code>&lt;form&gt;</code>元素<br>&emsp;document.images：所有<code>&lt;img&gt;</code>元素<br>&emsp;document.links：所有带href特性的<code>&lt;a&gt;</code>元素</li><li><strong>文档写入</strong>：write()、writeln()、open()、close()<br>&emsp;write()会原样写入，writeln()会在字符串末尾添加一个换行符<br>&emsp;如果在文档结束后再调用document.write()，那么输出的内容将会重写整个页面</li><li><strong>DOM一致性检测</strong><br>&emsp;<code>var hasXmlDom=document.implementation.hasFeature(&quot;XML&quot;,&quot;1.0&quot;)</code>如果浏览器支持给定名称和版本的功能，返回true。</li></ul><h4><span id="13element类型">1.3Element类型</span></h4><ul><li><strong> 操作特性</strong>：getAttribute()、setAttribute()、removeAttribute()<br>&emsp;特性的名称不区分大小写，即“ID”和“id”代表同一特性<br>&emsp;根据HTML5规范，自定义特性应该加上data-前缀以便验证</li><li><strong>attributes属性</strong><br>取得元素的id属性，可以使用以下代码：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取得元素的id属性</span></span><br><span class="line"><span class="keyword">var</span> id=element.attributes.getNamedItem(<span class="string">"id"</span>).nodeValue;<span class="comment">//方法1</span></span><br><span class="line"><span class="keyword">var</span> id=element.attributes[<span class="string">"id"</span>].nodeValue;<span class="comment">//方法2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置id特性的值</span></span><br><span class="line">element.attributes[<span class="string">"id"</span>].nodeValue = <span class="string">"someOtherId"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除id特性,removeNamedItem()返回被删除特性的Attr节点，removeAttribute()彻底删除元素的特性</span></span><br><span class="line"><span class="keyword">var</span> oldAttr=element.attributes.removeNamedItem(<span class="string">"id"</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>创建元素</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div=<span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">div.id=<span class="string">"myNewDiv"</span>;</span><br><span class="line">div.className=<span class="string">"box"</span>;<span class="comment">//class为保留字，所以使用className</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(div);<span class="comment">//新创建的元素添加到文档</span></span><br></pre></td></tr></table></figure><ul><li><strong>元素的子节点</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=<span class="string">"myList"</span>&gt;</span><br><span class="line">    &lt;li&gt;Item <span class="number">1</span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li&gt;Item 2&lt;/</span>li&gt;</span><br><span class="line">    &lt;li&gt;Item <span class="number">3</span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br><span class="line"><span class="comment">//IE来解析，&lt;ul&gt;会有3个子节点&lt;li&gt;元素</span></span><br><span class="line"><span class="comment">//其他浏览器解析，&lt;ul&gt;会有7个子节点，3个&lt;li&gt;，4个文本节点（空白符）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历子节点</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,len=element.childNodes.length;i&lt;len;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(element.nodeType==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：如ul含有更多层次的后代li元素，都会返回</span></span><br><span class="line"><span class="keyword">var</span> ul=<span class="built_in">document</span>.getElementById(<span class="string">"myList"</span>);</span><br><span class="line"><span class="keyword">var</span> items=ul.getElementsByTagName(<span class="string">"li"</span>);</span><br></pre></td></tr></table></figure><h4><span id="14text类型">1.4Text类型</span></h4><ul><li>parentNode是一个Element，nodeValue和data的值都为节点所包含的文本</li><li><strong>操作节点的方法</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">appendDate(text):将text添加到节点的末尾</span><br><span class="line">deleteData(offset,count):从offset指定的位置开始删除count个字符</span><br><span class="line">insertData(offset,text):从offset指定的位置插入text</span><br><span class="line">replaceData(offset,count,text):用text替换从offset指定的位置开始到offset+count为止处的文本</span><br><span class="line">splitText(offset):从offset指定的位置将当前文本节点分成两个文本节点</span><br><span class="line">substringData(offset,sount):提取从offset指定的位置开始到offset+count为止处的字符串</span><br><span class="line">nodeValue.length==data.length:保存文本节点字符的数目</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改文本节点的值</span></span><br><span class="line">div.firstChild.nodeValue=<span class="string">"....."</span>;<span class="comment">//div.childNodes[0].nodeValue="..."</span></span><br><span class="line"><span class="comment">//添加文本</span></span><br><span class="line">div.firstChild.appendData(<span class="string">"...."</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>创建文本节点creatTextNode()</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element=<span class="built_in">document</span>.createElement(div);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> textNode=<span class="built_in">document</span>.createTextNode(<span class="string">"Hello"</span>);</span><br><span class="line">element.appendChild(textNode);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(element);</span><br></pre></td></tr></table></figure><ul><li><strong>DoumentFragment类型</strong><br>&emsp;创建文本片段：<code>document.createDocumentFragment()</code>方法。避免浏览器反复渲染，可以把要创建的项先添加到文本片段，然后再添加至文档中</li></ul><h3><span id="2dom扩展">2.DOM扩展</span></h3><p>对DOM的两个主要扩展是Selectors API和HTML5。</p><ul><li><strong>选择符API</strong>:querySelector()和querySelectorAll()<br>&emsp;querySelector()返回与该模式匹配的第一个元素，document.querySelector()会在文档元素的范围内查找，element.querySelector()只会在该元素后代元素的范围内查找。<br>&emsp;querySelectorAll()返回的是所以匹配的元素</li><li><strong>元素遍历</strong><br>利用这些属性不必担心空白文本节点，更方便查找DOM元素</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">childElementCount:返回子元素（不包括文本节点和注释）的注释</span><br><span class="line">firstElementChild:指向第一个子元素；firstChild的元素版</span><br><span class="line">lastElementChild:指向最后一个子元素</span><br><span class="line">previousElementSibling:指向前一个同辈元素</span><br><span class="line">nextElementSibling:指向后一个同辈元素</span><br></pre></td></tr></table></figure><ul><li><p><strong>HTML5</strong></p><ul><li>getElementsByClassName()<br>&emsp;<code>document.getElementsByClassName(&quot;className1 className2&quot;)</code>取得所有类中包含“className1”和“className2”的元素</li><li>classList属性<br>&emsp;方法：add(value),contains(value),remove(value),toggle(value)<br>&emsp;如<code>div.classList.remove(&quot;className&quot;)</code></li><li><p>自定义数据属性<br>&emsp;如<code>&lt;div id=&quot;myDiv&quot; data-appId=&quot;123&quot; data-myname=&quot;wt&quot;&gt;&lt;/div&gt;</code>添加了自定义数据属性，可以通过元素的dataset属性来访问自定义属性的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取得自定义属性的值</span></span><br><span class="line"><span class="keyword">var</span> appId=div.dataset.appId;<span class="comment">//要去掉data-</span></span><br><span class="line"><span class="keyword">var</span> myname=div.dataset.myname;</span><br></pre></td></tr></table></figure></li><li><p>插入标记<br>&emsp;经常使用的：innerHTML和outerHTML属性(HTML5纳入标准)<br>&emsp;insertAdjacentHTML()方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"beforebegin"</span>,在当前元素之前插入一个紧邻的同辈元素</span><br><span class="line"><span class="string">"afterbegin"</span>,在当前元素之下插入一个新的子元素（成为当前元素的第一个子元素）</span><br><span class="line"><span class="string">"beforeend"</span>,(成为当前元素的最后一个子元素)</span><br><span class="line"><span class="string">"afterend"</span>,在当前元素之后插入一个紧邻的同辈元素</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">element.insertAdjacentElement(<span class="string">"beforebegin"</span>,<span class="string">"&lt;p&gt;text&lt;/p&gt;"</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>专业扩展</strong></p><ul><li>children属性，只包含元素节点，不考虑空白符<code>element.children[0]</code></li><li>contains()判断某个节点是不是另一个节点的后代，如<code>document.documentElement.contains(document.body)</code>返回true</li><li>innerText和outerText（HTML5未纳入标准）<br>&emsp;去掉div中的HTML标签可以：<code>div.innerText = div.innerText</code></li></ul></li></ul><h3><span id="3dom2和dom3">3.DOM2和DOM3</span></h3><p>&emsp;DOM1级主要定义的是HTML和XML文档的底层结构。DOM2和DOM3在于扩展DOM API，以满足操作XML的所有需求，同时提供更好的错误处理及特性检测能力。</p><ul><li><strong>DOM变化</strong><ul><li>针对XML命名空间的变化<br>&emsp;有了XML命名空间，不同XML文档的元素就可以混合在一起。</li><li>创建一个完整的HTML文档：<code>var htmldoc=document.implementation.createHTMLDocument(&quot;New Doc&quot;)</code>,只接受一个参数，为文档的标题。  </li></ul></li></ul><ul><li><p><strong>样式</strong></p><ul><li>JS访问样式的属性必须转换为驼峰式，如background-image得写成backgroundImage</li><li>float是JS保留字，访问float属性：cssFloat或styleFloat(IE)</li><li>DOM2级样式属性和方法（常用）：<code>cssText</code>，<code>length</code>，<code>item(index)</code>，<code>removeProperty(propertyName)</code><br>有：<code>myDiv.style.style[i]==myDiv.style.item(i)</code></li><li>偏移量：<code>offsetHeight</code>，<code>offsetWidth</code>，<code>offsetLeft</code>,<code>offsetTop</code><br><code>offsetHeight</code>，<code>offsetWidth</code>包括元素、滚动条、边框的高/宽<br>要想知道某个元素在页面上的偏移量，将这个元素的<code>offsetLeft</code>，<code>offsetTop</code>与其<code>offsetParent</code>的相同属性想加，如此循环直至根元素</li><li>客户区大小：<code>clientWidth</code>和<code>clientHeight</code>（内容区+内边距）  </li></ul></li></ul><ul><li><strong>遍历</strong><br>&emsp;完成顺序遍历DOM结构的类型：<code>NodeIterator</code>和<code>TreeWalker</code></li><li><strong>范围</strong><br>&emsp;通过范围可以选择文档中的一个区域，而不必考虑节点的界限。在常规的DOM操作不能更效地修改文档时，可以使用范围达到。但是目前来看，我还没有用到范围来操作文档内容，今后用到了再来翻阅。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;最近自己写项目的时候，DOM操作稍多，但是发现自己不是很熟悉，以前看过的知识不常用就忘了，用的时候也是要经常去官网或网上查找。所以想把DOM的知识点重新回顾一下，以下知识点来自“JavaScript高级程序设计”第10、11、12章节。另外，想自己练习DOM操作相关的题，推荐&lt;a href=&quot;http://ife.baidu.com/college/detail/id/10&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;百度前端技术学院&lt;/a&gt;的斌斌学院，上面有很多可操作的题，看的再多不如自己多思考多敲代码，这点我深有体会，可是吃了大亏的啊。&lt;/p&gt;
&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1dom1&quot;&gt;1.DOM1&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#11node类型&quot;&gt;1.1Node类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#12document类型&quot;&gt;1.2Document类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#13element类型&quot;&gt;1.3Element类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#14text类型&quot;&gt;1.4Text类型&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2dom扩展&quot;&gt;2.DOM扩展&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3dom2和dom3&quot;&gt;3.DOM2和DOM3&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;
    
    </summary>
    
      <category term="DOM操作" scheme="https://wtlemoney.github.io/categories/DOM%E6%93%8D%E4%BD%9C/"/>
    
      <category term="DOM选择器" scheme="https://wtlemoney.github.io/categories/DOM%E6%93%8D%E4%BD%9C/DOM%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    
    
      <category term="JavaScript" scheme="https://wtlemoney.github.io/tags/JavaScript/"/>
    
      <category term="DOM" scheme="https://wtlemoney.github.io/tags/DOM/"/>
    
      <category term="节点操作" scheme="https://wtlemoney.github.io/tags/%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C/"/>
    
      <category term="浏览器兼容" scheme="https://wtlemoney.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9/"/>
    
  </entry>
  
  <entry>
    <title>VScode常用快捷键</title>
    <link href="https://wtlemoney.github.io/2018/04/18/VScode%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>https://wtlemoney.github.io/2018/04/18/VScode快捷键/</id>
    <published>2018-04-18T09:11:30.000Z</published>
    <updated>2018-04-22T12:59:59.090Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#1编辑器与窗口管理">1.编辑器与窗口管理</a></li><li><a href="#2代码编辑">2.代码编辑</a><ul><li><a href="#格式调整">格式调整</a></li><li><a href="#光标相关">光标相关</a></li><li><a href="#查找替换">查找替换</a></li><li><a href="#显示相关">显示相关</a></li><li><a href="#重构代码">重构代码</a></li></ul></li></ul><!-- tocstop --><h3><span id="1编辑器与窗口管理">1.编辑器与窗口管理</span></h3><ul><li>新建文件：<code>Ctrl+N</code></li><li>打开一个新窗口：<code>Ctrl+Shift+N</code></li><li>关闭本窗口所有文件：<code>Ctrl+Shift+W</code><a id="more"></a></li><li>文件之间切换：<code>Ctrl+Tab</code></li><li>拆分编辑器：<code>Ctrl+\</code></li><li>左中右 3 个编辑器的快捷键：<code>Ctrl+1 Ctrl+2 Ctrl+3</code></li><li>编辑器换位置， <code>Ctrl+k</code>然后按 Left或 Right</li></ul><h3><span id="2代码编辑">2.代码编辑</span></h3><h4><span id="格式调整">格式调整</span></h4><ul><li>代码行缩进：<code>Ctrl+[</code>，<code>Ctrl+]</code></li><li>上下移动一行：<code>Alt+Up</code>，<code>Alt+Down</code></li><li>向上向下复制一行： <code>Shift+Alt+Up</code>,<code>Shift+Alt+Down</code></li><li>在当前行下边插入一行 ：<code>Ctrl+Enter</code></li><li>在当前行上方插入一行 ：<code>Ctrl+Shift+Enter</code></li></ul><h4><span id="光标相关">光标相关</span></h4><ul><li>移动到行首：<code>Home</code></li><li>移动到行尾：<code>End</code></li><li>选中当前行：<code>Ctrl+i</code></li><li>删除光标所在行:<code>Ctrl+Shift+K</code></li><li>删除光标右侧的所有字：<code>Ctrl+Delete</code></li><li>移动到文件结尾：<code>Ctrl+End</code></li><li>移动到文件开头：<code>Ctrl+Home</code></li><li>移动到定义处：<code>F12</code></li><li>定义处缩略图：只看一眼而不跳转过去 <code>Alt+F12</code></li><li>跳到匹配的括号：<code>Ctrl+Shift+\</code></li><li>选择从光标到行尾： <code>Shift+End</code></li><li>选择从行首到光标处：<code>Shift+Home</code></li><li>扩展/缩小选取范围： <code>Shift+Alt+Left</code> 和 <code>Shift+Alt+Right</code></li><li>多行编辑(列编辑)：<code>Alt+Shift+鼠标左键</code>，<code>Ctrl+Alt+Down/Up</code></li><li>选择当前字的所有出现：<code>Ctrl + F2</code></li><li>同时选中所有匹配： <code>Ctrl+Shift+L</code></li><li>下一个匹配的也被选中：<code>Ctrl+D</code></li><li>回退上一个光标操作：<code>Ctrl+U</code></li><li>切出块注释<code>/* */</code>：<code>Shift+Alt+A</code></li><li>切出上/下一个操作的文件：<code>Alt + ←/→</code></li></ul><h4><span id="查找替换">查找替换</span></h4><ul><li>查找：<code>Ctrl+F</code></li><li>查找下一个/上一个：<code>F3 / Shift + F3</code></li><li>查找替换：<code>Ctrl+H</code></li><li>整个文件夹中查找：<code>Ctrl+Shift+F</code></li></ul><h4><span id="显示相关">显示相关</span></h4><ul><li>全屏：<code>F11</code></li><li>侧边栏显/隐：<code>Ctrl+B</code></li><li>显示 Debug：<code>Ctrl+Shift+D</code></li><li>显示 Output：<code>Ctrl+Shift+U</code></li><li>显示/关闭终端：Ctrl+`</li></ul><h4><span id="重构代码">重构代码</span></h4><ul><li>找到所有的引用：<code>Shift+F12</code></li><li>同时修改本文件中所有匹配的：<code>Ctrl+F12</code></li><li>重命名：比如要修改一个方法名，可以选中后按 F2，输入新的名字，回车，会发现所有的文件都修改了</li><li>跳转到下一个 Error 或 Warning：<code>F8</code></li><li>跳转到上一个 Error 或 Warning：<code>Shift+F8</code></li><li>查看 diff： 在 explorer 里选择文件右键 Set file to compare，然后需要对比的文件上右键选择 Compare with file_name_you_chose</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1编辑器与窗口管理&quot;&gt;1.编辑器与窗口管理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2代码编辑&quot;&gt;2.代码编辑&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#格式调整&quot;&gt;格式调整&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#光标相关&quot;&gt;光标相关&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#查找替换&quot;&gt;查找替换&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#显示相关&quot;&gt;显示相关&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#重构代码&quot;&gt;重构代码&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;
&lt;h3 id=&quot;1-编辑器与窗口管理&quot;&gt;&lt;a href=&quot;#1-编辑器与窗口管理&quot; class=&quot;headerlink&quot; title=&quot;1.编辑器与窗口管理&quot;&gt;&lt;/a&gt;1.编辑器与窗口管理&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;新建文件：&lt;code&gt;Ctrl+N&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;打开一个新窗口：&lt;code&gt;Ctrl+Shift+N&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;关闭本窗口所有文件：&lt;code&gt;Ctrl+Shift+W&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="VScode编辑器" scheme="https://wtlemoney.github.io/categories/VScode%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
    
      <category term="VScode" scheme="https://wtlemoney.github.io/tags/VScode/"/>
    
      <category term="工具" scheme="https://wtlemoney.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="编辑器" scheme="https://wtlemoney.github.io/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>ajax知识总结</title>
    <link href="https://wtlemoney.github.io/2018/04/15/ajax/"/>
    <id>https://wtlemoney.github.io/2018/04/15/ajax/</id>
    <published>2018-04-15T14:04:38.000Z</published>
    <updated>2018-05-06T12:36:56.844Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#1onload和onreadychange的不同">1.onload和onreadychange的不同</a><ul><li><a href="#11-onload">1.1 onload</a></li><li><a href="#12-onreadychange">1.2 onreadychange</a></li></ul></li><li><a href="#2服务器返回的数据类型对比">2.服务器返回的数据类型对比</a></li><li><a href="#3把字符串转化为json对象">3.把字符串转化为JSON对象</a></li><li><a href="#4原生js实现ajax">4.原生JS实现ajax</a></li><li><a href="#5jquery中的ajax">5.jQuery中的ajax</a><ul><li><a href="#51-load方法">5.1 load方法</a></li><li><a href="#52-getpost方法">5.2 get/post方法</a></li><li><a href="#53-getjson方法">5.3 getJSON方法</a></li></ul></li></ul><!-- tocstop --><h4><span id="1onload和onreadychange的不同">1.onload和onreadychange的不同</span></h4><p>首先需要知道几个状态码的小知识。<br>&emsp;&emsp;readyState 状态码：</p><p>&emsp;&emsp;&emsp;&emsp;0 - 请求未初始化。还没有调用open方法</p><p>&emsp;&emsp;&emsp;&emsp;1 - 服务器连接已建立。open方法已被调用，但send方法还没有被调用</p><p>&emsp;&emsp;&emsp;&emsp;2 - 请求已接受。send方法以及被调用<a id="more"></a></p><p>&emsp;&emsp;&emsp;&emsp;3 - 请求处理中。服务器正在发送响应</p><p>&emsp;&emsp;&emsp;&emsp;4 - 请求已完成，响应发送完毕</p><p>&emsp;&emsp;HTTP 状态码(status)：</p><p>&emsp;&emsp;&emsp;&emsp;200 - 服务器成功返回网页</p><p>&emsp;&emsp;&emsp;&emsp;304 - 客户端已经执行了GET，但文件未变化。</p><p>&emsp;&emsp;&emsp;&emsp;403 - 禁止访问</p><p>&emsp;&emsp;&emsp;&emsp;404 - 请求的网页不存在</p><p>&emsp;&emsp;&emsp;&emsp;500 - 内部服务器出错</p><p>&emsp;&emsp;&emsp;&emsp;503 - 服务器暂时不可用<br>然后建立一个loadtest.txt文件作为ajax请求的测试url，注意一定要在本地服务器里面打开测试，不然请求文件会报跨域错误。</p><h5><span id="11-onload">1.1 onload</span></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'button'</span>).addEventListener(<span class="string">"click"</span>,loadText);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadText</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> xhr=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    xhr.open(<span class="string">'GET'</span>,<span class="string">"loadtext.txt"</span>,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Readystate："</span>,xhr.readyState);</span><br><span class="line"></span><br><span class="line">    xhr.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//readystate==4时才会进入onload,监听不到2和3</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Readystate："</span>,xhr.readyState);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><p><div align="center"><br>    <img src="/2018/04/15/ajax/11.png" width="320" height="100" alt="onload状态码结果"><br></div><br>如果要监听readystate为3的值，需要用到onprogress方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"Readystate："</span>,xhr.readyState);</span><br><span class="line">   xhr.onprogress=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//监听3</span></span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">"测试Readystate："</span>,xhr.readyState);</span><br><span class="line">   &#125;</span><br><span class="line">   xhr.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//readystate==4时才会进入onload,监听不到2和3</span></span><br></pre></td></tr></table></figure></p><p>测试结果如下：</p><p><div align="center"><br>    <img src="/2018/04/15/ajax/2.png" width="320" height="100" alt="onload状态码结果"><br></div></p><h5><span id="12-onreadychange">1.2 onreadychange</span></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadText</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> xhr=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    xhr.open(<span class="string">'GET'</span>,<span class="string">"loadtext.txt"</span>,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Readystate："</span>,xhr.readyState);</span><br><span class="line"></span><br><span class="line">    xhr.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//可以监听到所有的状态码2,3,4</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Readystate："</span>,xhr.readyState);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.responseText);<span class="comment">//在readyState=2和3的时候都打印responseText</span></span><br><span class="line">    &#125;</span><br><span class="line">    xhr.send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><p><div align="center"><br>    <img src="/2018/04/15/ajax/3.png" width="320" height="150" alt="onreadystate状态码结果"><br></div><br>看出onreadychange和onload方法的区别了昂。想要在readyState==4的时候再打印responseText，可以加一个条件判断：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">xhr.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//可以监听到所有的状态码2,3,4</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Readystate："</span>,xhr.readyState);</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.status==<span class="number">200</span>&amp;&amp;<span class="keyword">this</span>.readyState==<span class="number">4</span>)&#123;<span class="comment">//监听到4时再执行</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试结果：</p><p><div align="center"><br>    <img src="/2018/04/15/ajax/4.png" width="320" height="125" alt="onreadystate状态码结果"><br></div><br>一般在用ajax请求数据时，还会设置返回失败时的值。这时候把loadtest.txt改为loadtest1.txt，然后<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.status==<span class="number">200</span>&amp;&amp;<span class="keyword">this</span>.readyState==<span class="number">4</span>)&#123;<span class="comment">//监听4时再执行</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.responseText);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.status==<span class="number">404</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"请求的网页不存在"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试结果：</p><p><div align="center"><br>    <img src="/2018/04/15/ajax/5.png" width="320" height="180" alt="404结果"><br></div><br>注意：如果用POST请求向服务器发送数据，需要将“Content-type”的首部设置为“application/x-www-form-urlencoded”,它会告知服务器正在发送数据，并且数据已经符合URL编码了。<br>即：<code>xhr.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;)</code>,该方法必须在open()之后才能调用。</p><h4><span id="2服务器返回的数据类型对比">2.服务器返回的数据类型对比</span></h4><p>HTML片段：</p><ul><li>从服务器端发送的HTML代码在浏览器端不需要用JavaScript进行解析</li><li>HTML可读性好</li><li>HTML代码块与innerHTML属性搭配，效率高</li></ul><ul><li>若需要通过ajax更新一篇文档的多个部分，HTML不合适，可重用性低</li><li>innerHTML并非DOM标准</li></ul><p>XML文档：</p><ul><li>可移植性是其他数据格式无法比拟的，重用性高</li><li>通用的数据交换格式</li></ul><ul><li>实现过程较HTML片段要复杂许多</li><li>XML文件体积大，笨重。</li></ul><p>JSON文件：</p><ul><li>作为一种数据传输格式，JSON与XML相似，但是JSON更加灵巧</li><li>可重用</li><li>JSON不需要从服务器端发送含有特定内容类型的首部信息</li></ul><ul><li>语法过于严谨</li><li>代码不易读</li><li>eval函数存在风险</li></ul><p>对比：<br>若应用程序不需要与其他应用程序共享数据的时候，使用HTML片段来返回数据时是最简单的<br>如果数据需要重用，JSON文件是个不错的选择，它在性能和文件大小方面有有事（90%情况使用JSON）<br>当远程应用程序未知时，XML文档是首选，因为听说XML是“世界语”</p><h4><span id="3把字符串转化为json对象">3.把字符串转化为JSON对象</span></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonStr=<span class="string">'&#123;"name":"hhhhhaaaaa"&#125;'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(jsonStr.name);<span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用eval()方法,它可以把一个字符串转化为本地的JS代码来执行</span></span><br><span class="line"><span class="keyword">var</span> testStr=<span class="built_in">eval</span>(<span class="string">"("</span>+jsonStr+<span class="string">")"</span>);<span class="comment">//注意要加括号！把JSON对象转化为JSON字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(testStr.name);<span class="comment">//hhhhhaaaaa</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(jsonStr))；<span class="comment">//&#123;name: "hhhhhaaaaa"&#125;</span></span><br></pre></td></tr></table></figure><h4><span id="4原生js实现ajax">4.原生JS实现ajax</span></h4><p>下面这段代码是做项目写ajax请求时，经常使用的代码段，非常好用！<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">type,url,param,callback</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> xhr=<span class="keyword">new</span> XMLHttpRequest();<span class="comment">//新建连接</span></span><br><span class="line"></span><br><span class="line">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//监听连接</span></span><br><span class="line">        <span class="keyword">if</span>(xhr.readyState===<span class="number">4</span>&amp;&amp;xhr.status===<span class="number">200</span>)&#123;</span><br><span class="line">            <span class="comment">//do something</span></span><br><span class="line">            callback(<span class="built_in">JSON</span>.parse(xhr.responseText));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//console.log(xhr.status)//打印状态</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> reg=<span class="regexp">/\?$/</span>;</span><br><span class="line">    <span class="keyword">if</span>(type===<span class="string">"GET"</span>)&#123;<span class="comment">//GET方法</span></span><br><span class="line">        xhr.open(<span class="string">'GET'</span>,reg.test(url)?url+param:url+<span class="string">'?'</span>+param,<span class="literal">true</span>);</span><br><span class="line">        xhr.send();</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type===<span class="string">"POST"</span>)&#123;<span class="comment">//POST方法</span></span><br><span class="line">        xhr.open(<span class="string">'POST'</span>,url,<span class="literal">true</span>);</span><br><span class="line">        xhr.setRequestHeader(<span class="string">"Content-type"</span>,<span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">        xhr.send(param);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4><span id="5jquery中的ajax">5.jQuery中的ajax</span></h4><h5><span id="51-load方法">5.1 load方法</span></h5><p>jQury最简单和最常用的方法，结构是：<code>load(url[,data][,callback])</code>。data这个参数有/无，决定了ajax请求方式是POST/GET。注意下例请求的是html文件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">     $(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         $(<span class="string">"a"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">             <span class="keyword">var</span> url=<span class="keyword">this</span>.href;<span class="comment">//内容为:&lt;h2&gt;我是Andy的文档&lt;/h2&gt;</span></span><br><span class="line">                                     <span class="comment">//&lt;a href="wting.top"&gt;wting.top&lt;/a&gt;</span></span><br><span class="line">             <span class="comment">//var args=&#123;"time":new Date()&#125;;//去掉缓存</span></span><br><span class="line">             <span class="comment">//$("#details").load(url,args);//加参数为POST方法，不加参数为GET方法</span></span><br><span class="line">             $(<span class="string">"#details"</span>).load(url);</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//取消a节点的默认行为</span></span><br><span class="line">         &#125;)</span><br><span class="line">     &#125;)</span><br><span class="line"> &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"> &lt;h1&gt;People&lt;/</span>h1&gt;</span><br><span class="line"> &lt;ul&gt;</span><br><span class="line">         &lt;li&gt;&lt;a href="andy.html"&gt;Andy&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">         &lt;li&gt;&lt;a href=""&gt;Richard&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">         &lt;li&gt;&lt;a href=""&gt;Jeremy&lt;/a&gt;&lt;/li&gt;</span><br><span class="line"> &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp"> &lt;div id="details"&gt;&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure><p>点击Andy，看测试结果：</p><p><div align="center"><br>    <img src="/2018/04/15/ajax/6.png" width="200" height="200" alt="404结果"><br></div></p><ul><li>load方法一般用来请求html代码。</li><li>如果只需要加载目标HTML页面内的某些元素，可以通过URL参数指定选择符，可以方便的从加载过来的HTML文档中选出最需要的内容，URL参数的语法结构为<code>url selector</code>(注意中间有个空格)。如上例中，可以只选andy.html中的h2标签，如<code>url=this.href+&quot; h2 &quot;;</code></li><li>对于必须在加载完才能继续的操作，load()方法提供了callback这个回调函数。callback有三个参数：代表请求返回内容的data；代表请求状态的textStatus；XMLHTTPRequest对象；</li><li>任何一个html都可以使用load方法来加载ajax,结果将直接插入html节点中。</li></ul><h5><span id="52-getpost方法">5.2 get/post方法</span></h5><p>只需要把load方法的那一条语句改成下面这样，get/post通用，注意这里请求的url为xml格式（三种数据格式都可以）：<code>&lt;name&gt;我是Andy&lt;/name&gt;</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$.post(url,args,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name=$(data).find(<span class="string">"name"</span>).text();</span><br><span class="line">&#125;)</span><br><span class="line">$(<span class="string">"#details"</span>).empty().append(<span class="string">"&lt;h2&gt;"</span>+name+<span class="string">"&lt;/h2&gt;"</span>);</span><br></pre></td></tr></table></figure><h5><span id="53-getjson方法">5.3 getJSON方法</span></h5><p>请求的数据格式为JSON格式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$.getJSON(url,args,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name=data.person.name;<span class="comment">//&#123;"person":&#123;"name":"wt"&#125;&#125;</span></span><br><span class="line">&#125;);</span><br><span class="line">$(<span class="string">"#details"</span>).empty().append(<span class="string">"&lt;h2&gt;"</span>+name+<span class="string">"&lt;/h2&gt;"</span>);</span><br></pre></td></tr></table></figure><p>如果把getJSON写成get,是解析不到数据的，因为我们得告诉jQuery我们请求的数据类型是JSON。可以这样改：<code>$.get(url,args,function(data){...},&quot;JSON&quot;)</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1onload和onreadychange的不同&quot;&gt;1.onload和onreadychange的不同&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#11-onload&quot;&gt;1.1 onload&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#12-onreadychange&quot;&gt;1.2 onreadychange&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2服务器返回的数据类型对比&quot;&gt;2.服务器返回的数据类型对比&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3把字符串转化为json对象&quot;&gt;3.把字符串转化为JSON对象&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#4原生js实现ajax&quot;&gt;4.原生JS实现ajax&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#5jquery中的ajax&quot;&gt;5.jQuery中的ajax&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#51-load方法&quot;&gt;5.1 load方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#52-getpost方法&quot;&gt;5.2 get/post方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#53-getjson方法&quot;&gt;5.3 getJSON方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;
&lt;h4 id=&quot;1-onload和onreadychange的不同&quot;&gt;&lt;a href=&quot;#1-onload和onreadychange的不同&quot; class=&quot;headerlink&quot; title=&quot;1.onload和onreadychange的不同&quot;&gt;&lt;/a&gt;1.onload和onreadychange的不同&lt;/h4&gt;&lt;p&gt;首先需要知道几个状态码的小知识。&lt;br&gt;&amp;emsp;&amp;emsp;readyState 状态码：&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;0 - 请求未初始化。还没有调用open方法&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;1 - 服务器连接已建立。open方法已被调用，但send方法还没有被调用&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;2 - 请求已接受。send方法以及被调用&lt;/p&gt;
    
    </summary>
    
      <category term="Ajax请求" scheme="https://wtlemoney.github.io/categories/Ajax%E8%AF%B7%E6%B1%82/"/>
    
      <category term="HTTP" scheme="https://wtlemoney.github.io/categories/Ajax%E8%AF%B7%E6%B1%82/HTTP/"/>
    
      <category term="状态码" scheme="https://wtlemoney.github.io/categories/Ajax%E8%AF%B7%E6%B1%82/HTTP/%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    
      <category term="JavaScript" scheme="https://wtlemoney.github.io/categories/Ajax%E8%AF%B7%E6%B1%82/HTTP/%E7%8A%B6%E6%80%81%E7%A0%81/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://wtlemoney.github.io/tags/JavaScript/"/>
    
      <category term="ajax" scheme="https://wtlemoney.github.io/tags/ajax/"/>
    
      <category term="JSON" scheme="https://wtlemoney.github.io/tags/JSON/"/>
    
      <category term="XML" scheme="https://wtlemoney.github.io/tags/XML/"/>
    
  </entry>
  
  <entry>
    <title>令人迷惑的“构造函数”</title>
    <link href="https://wtlemoney.github.io/2018/04/14/%E5%8E%9F%E5%9E%8B/"/>
    <id>https://wtlemoney.github.io/2018/04/14/原型/</id>
    <published>2018-04-14T15:55:54.000Z</published>
    <updated>2018-04-14T15:57:53.053Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">   Foo.prototype.constructor === Foo;<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> a=<span class="keyword">new</span> Foo();</span><br><span class="line">   a.constructor === Foo;<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Foo.prototype默认有一个公有并且不可枚举的属性.constructor,但a.constructor === Foo不意味着a有一个指向Foo的.constructor属性。实际上,.constructor引用同样被委托给了Foo.prototype,而Foo.prototype.constructor默认指向Foo。<br>&emsp;&emsp;如果创建了一个新对象并替换了函数默认的.prototype对象引用,那么新对象并不会自动获得.constructor属性：<a id="more"></a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;<span class="comment">/* .. */</span>&#125;</span><br><span class="line">Foo.prototype =&#123;<span class="comment">/* .. */</span>&#125;<span class="comment">//创建一个新原型对象。丢失了.constructor属性</span></span><br><span class="line">Foo.prototype.constructor === Foo;<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a1=<span class="keyword">new</span> Foo();</span><br><span class="line">a1.constructor === Foo;<span class="comment">//false</span></span><br><span class="line">a1.constructor === <span class="built_in">Object</span>;<span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;可以手动添加一个符合正常行为的不可枚举属性.constructor,修复.constructor需要很多收到操作，所有这些都源于把“constructor”错误地理解为“有……构造”。手动添加.constructor属性：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;<span class="comment">/* .. */</span>&#125;</span><br><span class="line">Foo.prototype =&#123;<span class="comment">/* .. */</span>&#125;<span class="comment">//创建一个新原型对象。丢失了.constructor属性</span></span><br><span class="line"><span class="comment">//需要在Foo.prototype“修复”丢失的.constructor属性</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Foo.prototype,<span class="string">"constructor"</span>,&#123;</span><br><span class="line">    enumerable:<span class="literal">false</span>,</span><br><span class="line">    writable:<span class="literal">true</span>,</span><br><span class="line">    configurable:<span class="literal">true</span>,</span><br><span class="line">    value:Foo <span class="comment">//让.constructor指向Foo</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Foo&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;//...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   Foo.prototype.constructor === Foo;&lt;span class=&quot;comment&quot;&gt;//true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a=&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Foo();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   a.constructor === Foo;&lt;span class=&quot;comment&quot;&gt;//true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;Foo.prototype默认有一个公有并且不可枚举的属性.constructor,但a.constructor === Foo不意味着a有一个指向Foo的.constructor属性。实际上,.constructor引用同样被委托给了Foo.prototype,而Foo.prototype.constructor默认指向Foo。&lt;br&gt;&amp;emsp;&amp;emsp;如果创建了一个新对象并替换了函数默认的.prototype对象引用,那么新对象并不会自动获得.constructor属性：&lt;/p&gt;
    
    </summary>
    
      <category term="构造函数" scheme="https://wtlemoney.github.io/categories/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
      <category term="你不知道的JavaScript" scheme="https://wtlemoney.github.io/categories/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://wtlemoney.github.io/tags/JavaScript/"/>
    
      <category term="blogs" scheme="https://wtlemoney.github.io/tags/blogs/"/>
    
      <category term="原型" scheme="https://wtlemoney.github.io/tags/%E5%8E%9F%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>腾讯IMWeb前端训练营作业——经典面试题2</title>
    <link href="https://wtlemoney.github.io/2018/04/07/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95%E9%A2%982/"/>
    <id>https://wtlemoney.github.io/2018/04/07/腾讯面试题2/</id>
    <published>2018-04-07T12:59:48.000Z</published>
    <updated>2018-04-19T11:32:13.546Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#1-box-sizing常用的属性有哪些分别有什么作用">1. box-sizing常用的属性有哪些？分别有什么作用？</a></li><li><a href="#2-doctype作用标准模式和兼容模式各有什么区别">2. Doctype作用？标准模式和兼容模式各有什么区别？</a></li><li><a href="#3-html5为什么只需要写doctype-html">3. HTML5为什么只需要写&lt;!DOCTYPE html&gt;？</a></li><li><a href="#4-页面导入样式时使用link和import有什么区别">4. 页面导入样式时，使用link和@import有什么区别？</a></li><li><a href="#5-介绍一下你对浏览器内核的理解">5. 介绍一下你对浏览器内核的理解？</a></li><li><a href="#6-ie和dom事件流的区别">6. IE和DOM事件流的区别？</a></li><li><a href="#7-哪些地方会出现css阻塞或js阻塞">7. 哪些地方会出现CSS阻塞或js阻塞？</a></li><li><a href="#8-说说你对svg的理解">8. 说说你对SVG的理解？</a></li><li><a href="#9-如何视觉隐藏网页内容只让他们在屏幕阅读器中可用">9. 如何视觉隐藏网页内容，只让他们在屏幕阅读器中可用？</a></li><li><a href="#10-你如何对网站的文件和资源进行优化">10. 你如何对网站的文件和资源进行优化？</a></li><li><a href="#11web前端密码加密是否有意义">11.web前端密码加密是否有意义？</a></li><li><a href="#12平时如何管理你的项目">12.平时如何管理你的项目？</a></li></ul><!-- tocstop --><h4><span id="1-box-sizing常用的属性有哪些分别有什么作用">1. box-sizing常用的属性有哪些？分别有什么作用？</span></h4><p><strong>属性值</strong></p><ul><li>box-sizing：content-box</li><li>box-sizing：border-box</li><li>box-sizing：inherit</li></ul><p><strong>content-box</strong></p><ul><li>这是box-sizing的默认属性值<a id="more"></a> </li><li>是CSS2.1中规定的宽度高度的显示行为</li><li>在CSS中定义的宽度和高度就对应到元素的内容框</li><li>在CSS中定义的宽度和高度之外绘制元素的内边距和边框</li></ul><p><strong>border-box</strong></p><ul><li>在CSS中微元素设定的宽度和高度就决定了元素的边框盒</li><li>即为元素在设置内边距和边框是在已经设定好的宽度和高度之内进行绘制</li><li>CSS中设定的宽度和高度减去边框和内间距才能得到元素内容所占的实际宽度和高度</li></ul><p><strong>inherit</strong></p><ul><li>规定元素是从父元素那里继承box-sizing的属性值</li></ul><h4><span id="2-doctype作用标准模式和兼容模式各有什么区别">2. Doctype作用？标准模式和兼容模式各有什么区别？</span></h4><p><strong>作用</strong></p><ul><li>告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式（怪异模式）呈现。</li></ul><p><strong>语法</strong></p><ul><li>HTML 顶级元素 可用性 “注册//组织//类型 标签//定义 语言””URL”；</li></ul><p><strong>举例</strong></p><ul><li>&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.0//EN”&gt; </li><li>&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.0 Strict//EN”&gt;<br>&emsp;&emsp;其中，DTD的是W3C所发布的一个文档类型定义，简单的说，就是告诉浏览器你的这个HTML，是根据哪个标准写的，解析的时候用哪个标准解析。</li></ul><p><strong>标准模式与兼容模式（怪异模式）各有什么区别?</strong></p><ul><li>标准模式的排版和JS运作模式都是以该浏览器支持的最高标准运行。</li><li>在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。简单的说，就是尽可能的显示能显示的东西给用户看。</li></ul><p><strong>具体区别</strong></p><ul><li><p>width不同<br>&emsp;&emsp;在严格模式中 ：width是内容宽度 ，元素真正的宽度 = margin-left + border-left-width + padding-left + width + padding-right + border-right- width +  margin-right;<br>&emsp;&emsp;在兼容模式中 ：width则是元素的实际宽度 ，内容宽度 = width - ( padding-left + padding-right + border-left-width + border-right-width);</p></li><li><p>兼容模式下可设置百分比的高度和行内元素的高宽<br>&emsp;&emsp;在Standards模式下，给span等行内元素设置wdith和height都不会生效，而在兼容模式下，则会生效。<br>&emsp;&emsp;在standards模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置高度，子元素设置一个百分比的高度是无效的。</p></li><li><p>用margin:0 auto设置水平居中在IE下会失效<br>&emsp;&emsp;使用margin:0 auto在standards模式下可以使元素水平居中，但在兼容模式下却会失效（用text-align属性解决）</p></li><li><p>兼容模式下Table中的字体属性不能继承上层的设置，white-space:pre会失效，设置图片的padding会失效</p></li></ul><h4><span id="3-html5为什么只需要写ltdoctype-htmlgt">3. HTML5为什么只需要写&lt;!DOCTYPE html&gt;？</span></h4><p>&emsp;&emsp;html5不基于SGML(标准通用标记语言)，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照他们应该的方式来运行）。而HTML4.01基于SGML，所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。</p><h4><span id="4-页面导入样式时使用link和import有什么区别">4. 页面导入样式时，使用link和@import有什么区别？</span></h4><p>外部样式表另一种写法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type=”text/css”&gt;</span><br><span class="line">    @<span class="keyword">import</span> url（“a.css”）；</span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>与link区别</strong>:</p><ul><li><p>老祖宗的差别。link属于XHTML标签，而@import完全是CSS提供的一种方式。link标签除了可以加载CSS外，还可以做很多其它的事情，比如定义RSS，定义rel连接属性等，@import就只能加载CSS了。 　</p></li><li><p>加载顺序的差别。当一个页面被加载的时候（就是被浏览者浏览的时候），link引用的CSS会同时被加载，而@import引用的CSS会等到页面全部被下载完再被加载。所以有时候浏览@import加载CSS的页面时开始会没有样式（就是闪烁），网速慢的时候还挺明显（梦之都加载CSS 的方式就是使用@import，一边下载一边浏览梦之都网页时，就会出现上述问题）。 　　</p></li><li><p>兼容性的差别。由于@import是CSS2.1提出的，所以老的浏览器不支持，@import只有在IE5以上的才能识别，而link标签无此问题。 　　</p></li></ul><ul><li>使用dom控制样式时的差别。当使用javascript控制dom去改变样式的时候，只能使用link标签，因为@import不是dom可以控制的。</li></ul><h4><span id="5-介绍一下你对浏览器内核的理解">5. 介绍一下你对浏览器内核的理解？</span></h4><p>&emsp;&emsp;主要分成两个部分：渲染引擎(Render Engine)和JS引擎。最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向与只指渲染引擎。</p><ul><li><p><strong>渲染引擎</strong>：负责取得网页的内容(html,xml和图像等)，整理讯息(例如假如css)，以及计算网页的显示方式，然后输出到显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不同，这也是网页编写者需要在不同内核的浏览器中测试网页显示效果的原因。所有网页浏览器、电子邮件客户端以及它需要编辑、显示网络内容的应用程序都需要内核。</p></li><li><p><strong>JS引擎</strong>：解析和执行JavaScript来实现网页的动态效果。</p></li><li><p><strong>常见的浏览器内核有哪些？</strong><br>Trident内核：IE，360，搜狗浏览器，百度浏览器（早期版本）；<br>Gecko内核：Netscape6及以上版本，Firefox<br>Presto内核：Opera前内核（已废弃）<br>Blink内核：Opera<br>Webkit内核：Safari，Chrome，Android默认浏览器</p></li><li><p><strong>常见的JS引擎有哪些？</strong><br>现今比较出名的有Chorme浏览器的V8引擎、Safari浏览器的Chakra（查克拉）、JSCore(FF4.0+)。</p></li></ul><h4><span id="6-ie和dom事件流的区别">6. IE和DOM事件流的区别？</span></h4><ul><li><p><strong>事件流的区别 </strong></p><p>IE采用冒泡型事件<br>Netscape使用捕获型事件<br>DOM使用先捕获后冒泡型事件 </p></li></ul><p>示例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt; </span><br><span class="line">&lt;div&gt; </span><br><span class="line">&lt;button&gt;点击这里&lt;<span class="regexp">/button&gt; </span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt; </span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br></pre></td></tr></table></figure></p><p>冒泡型事件模型： button-&gt;div-&gt;body (IE事件流) </p><p>捕获型事件模型： body-&gt;div-&gt;button (Netscape事件流) </p><p>DOM事件模型： body-&gt;div-&gt;button-&gt;button-&gt;div-&gt;body (先捕获后冒泡)</p><ul><li><p><strong>事件侦听函数的区别 </strong></p><p>IE使用: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">Object</span>].attachEvent(<span class="string">"name_of_event_handler"</span>, fnHandler); <span class="comment">//绑定函数 </span></span><br><span class="line">[<span class="built_in">Object</span>].detachEvent(<span class="string">"name_of_event_handler"</span>, fnHandler); <span class="comment">//移除绑定</span></span><br></pre></td></tr></table></figure><p>DOM使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">Object</span>].addEventListener(<span class="string">"name_of_event"</span>, fnHandler, bCapture); <span class="comment">//绑定函数 </span></span><br><span class="line">[<span class="built_in">Object</span>].removeEventListener(<span class="string">"name_of_event"</span>, fnHandler, bCapture); <span class="comment">//移除绑定</span></span><br></pre></td></tr></table></figure><p>bCapture参数用于设置事件绑定的阶段，true为捕获阶段，false为冒泡阶段。</p></li><li><p><strong>阻止事件的传播的区别</strong></p><p>无论是事件冒泡还是事件捕获都是可以阻止的。</p><p>（1）阻止事件的传播方法：在W3C标准中，<code>stopPropagation()</code>。在IE中，通过设置<code>cancelBubble = true</code>;<br>（2）阻止事件的默认行为：在W3C标准中，使用<code>preventDefault()</code>。在IE中通过设置<code>window.event.returnValue = false</code>;</p></li></ul><h4><span id="7-哪些地方会出现css阻塞或js阻塞">7. 哪些地方会出现CSS阻塞或js阻塞？</span></h4><p><strong>CSS怎么会阻塞加载了？</strong><br>&emsp;&emsp;CSS本来是可以并行下载的，在什么情况下会出现阻塞加载？(在测试观察中,IE6下CSS都是阻塞加载）。当CSS后面跟着嵌入的JS的时候,该CSS就会出现阻塞后面资源下载的情况，而当把嵌入JS放到CSS前面,就不会出现阻塞的情况了。<br>根本原因？<br>&emsp;&emsp;因为浏览器会维持html中css和js的顺序,样式表必须在嵌入的JS执行前先加载、解析完。<br>&emsp;&emsp;而嵌入的JS会阻塞后面的资源加载,所以就会出现上面CSS阻塞下载的情况。<br>嵌入JS应该放在什么位置？<br>&emsp;&emsp;1）放在底部,虽然放在底部照样会阻塞所有呈现,但不会阻塞资源下载。<br>&emsp;&emsp;2）如果嵌入JS放在head中,请把嵌入JS放在CSS头部。<br>&emsp;&emsp;3）使用defer（只支持IE）<br>&emsp;&emsp;4）不要在嵌入的JS中调用运行时间较长的函数,如果一定要用,可以用<code>setTimeout</code>来调用<br><strong>js的阻塞特性</strong>：<br>&emsp;&emsp;所有浏览器在下载JS的时候,会阻止一切其他活动,比如其他资源的下载,内容的呈现等等。直到JS下载、解析、执行完毕后才开始继续并行下载其他资源并呈现内容。为了提高用户体验,新一代浏览器都支持并行下载JS,但是JS下载仍然会阻塞其它资源的下载（例如.图片,css文件等）。<br>&emsp;&emsp;由于浏览器为了防止出现JS修改DOM树,需要重新构建DOM树的情况,所以就会阻塞其他的下载和呈现。嵌入JS会阻塞所有内容的呈现,而外部JS只会阻塞其后内容的显示,2种方式都会阻塞其后资源的下载。也就是说外部样式不会阻塞外部脚本的加载,但会阻塞外部脚本的执行。</p><h4><span id="8-说说你对svg的理解">8. 说说你对SVG的理解？</span></h4><ul><li>SVG 指可伸缩矢量图形 (Scalable Vector Graphics)</li><li>SVG 使用 XML 格式定义用于网络的基于矢量的图形</li><li>SVG 图像在放大或改变尺寸的情况下其图形质量不会有所损失，图像可在任何的分辨率下被高质量地打印</li><li>SVG 是万维网联盟的标准，与诸如 DOM 和 XSL 之类的 W3C 标准是一个整体</li><li>SVG 图像中的文本是可选的，同时也是可搜索的（很适合制作地图）</li></ul><h4><span id="9-如何视觉隐藏网页内容只让他们在屏幕阅读器中可用">9. 如何视觉隐藏网页内容，只让他们在屏幕阅读器中可用？</span></h4><ul><li><p>display:none;的缺陷搜索引擎可能认为被隐藏的文字属于垃圾信息而被忽略屏幕阅读器（是为视觉上有障碍的人设计的读取屏幕内容的程序）会忽略被隐藏的文字。</p></li><li><p>visibility:hidden;的缺陷这个大家应该比较熟悉就是隐藏的内容会占据他所应该占据物理空间</p></li><li><p>overflow:hidden;一个比较合理的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.texthidden&#123;<span class="attr">display</span>:block;<span class="comment">/*统一转化为块级元素*/</span></span><br><span class="line">overflow:hidden;width:<span class="number">0</span>;height:<span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure><p>就像上面的一段CSS所展示的方法，将宽度和高度设定为0，然后超过部分隐藏，就会弥补上述一、二方法中的缺陷，也达到了隐藏内容的目的。</p></li></ul><h4><span id="10-你如何对网站的文件和资源进行优化">10. 你如何对网站的文件和资源进行优化？</span></h4><ul><li><p>文件合并（目的是减少http请求）：使用css sprites合并图片，一个网站经常使用小图标和小图片进行美化，但是很遗憾这些小图片占用了大量的HTTP请求，因此可以采用sprites的方式把所有的图片合并成一张图片 ，可以通过相关工具在线合并，也可以在ps中合并。</p></li><li><p>使用CDN（内容分发网络）加速，降低通信距离。</p></li><li><p>缓存的使用，添加Expire/Cache-Control头。</p></li><li><p>启用Gzip压缩文件。</p></li><li><p>将css放在页面最上面,将script放在页面最下面,避免在css中使用表达式。</p></li><li><p>将css, js都放在外部文件中。</p></li><li><p>减少DNS查询。</p></li><li><p>文件压缩：最小化css, js，减小文件体积。</p></li><li><p>使用AJAX缓存，让网站内容分批加载，局部更新。</p></li></ul><h4><span id="11web前端密码加密是否有意义">11.web前端密码加密是否有意义？</span></h4><ul><li><p><strong>前端加密的意义</strong> </p><p>1）在 HTTP 协议下，数据是明文传输，传输过程中网络嗅探可直接获取其中的数据。如用户的密码和信用卡相关的资料，一旦被中间人获取，会给用户带来极大的安全隐患。<br>2）前端使用哈希算法，不仅可以帮助后端分担部分计算压力，还可以增加撞库成本。<br>3）另一方面，在非加密的传输过程中，攻击者可更改数据或插入恶意的代码等。HTTPS 的诞生就是为了解决中间人攻击的问题，但如今 HTTPS 的使用情况在国内并不乐观，基本是因为成本或者性能的考量。</p></li><li><p>那么问题来了，如果仍然使用 HTTP 协议，怎么样一定程度保证用户的数据安全？ </p><p>前端加密，即在数据发送前，将数据进行哈希或使用公钥加密。如果数据被中间人获取，拿到的则不再是明文。</p></li><li><p><strong>传md5和传明文一样？</strong><br>绝对不一样啊。链路被监听的时候，攻击人直接就拿到明文密码了，有很多人都习惯用一个密码的。明文的话，相当于直接把用户n多个网站的密码爆了，拿到md5的话，只有自己的网站密码被爆。对用户的危害范围明显缩小了好么。多少次用户icloud艳照泄露，最后都不是苹果的锅。。是别的网站被脱了好么。</p><p>有一种有效实践是发送用户密码+时间戳的md5值。这样可以有效避免被监听。当然还要做一点客户端和服务器端时间差计算的工作量。哪怕被监听。攻击人拿到的加密后密码也很快失效。在做一点单帐号单登录的措施，用户密码安全性还是可以得到很大的保证的。</p></li><li><p>前端 hash 的好处 </p><p>（1）避免明文密码在传输中被获取<br>（2）保证后端日志等不会记录明文密码（也可以防止内鬼盗窃）<br>（3）保证后端内存中无用户明文密码，在 dump 等情况发生时不会出现泄露问题 </p></li></ul><h4><span id="12平时如何管理你的项目">12.平时如何管理你的项目？</span></h4><ul><li>先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等</li><li>编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）</li><li>标注样式编写人，各模块都及时标注（标注关键样式调用的地方）</li><li>页面进行标注（例如 页面 模块 开始和结束）</li><li>CSS 跟 HTML 分文件夹并行存放，命名都得统一，如index.css和index.html</li><li>JS 分文件夹存放，命名以该 JS 功能为准的英文翻译</li><li>图片采用整合的png8格式，尽量整合在一起使用，方便将来的管理。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-box-sizing常用的属性有哪些分别有什么作用&quot;&gt;1. box-sizing常用的属性有哪些？分别有什么作用？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-doctype作用标准模式和兼容模式各有什么区别&quot;&gt;2. Doctype作用？标准模式和兼容模式各有什么区别？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3-html5为什么只需要写doctype-html&quot;&gt;3. HTML5为什么只需要写&amp;lt;!DOCTYPE html&amp;gt;？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#4-页面导入样式时使用link和import有什么区别&quot;&gt;4. 页面导入样式时，使用link和@import有什么区别？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#5-介绍一下你对浏览器内核的理解&quot;&gt;5. 介绍一下你对浏览器内核的理解？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#6-ie和dom事件流的区别&quot;&gt;6. IE和DOM事件流的区别？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#7-哪些地方会出现css阻塞或js阻塞&quot;&gt;7. 哪些地方会出现CSS阻塞或js阻塞？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#8-说说你对svg的理解&quot;&gt;8. 说说你对SVG的理解？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#9-如何视觉隐藏网页内容只让他们在屏幕阅读器中可用&quot;&gt;9. 如何视觉隐藏网页内容，只让他们在屏幕阅读器中可用？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#10-你如何对网站的文件和资源进行优化&quot;&gt;10. 你如何对网站的文件和资源进行优化？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#11web前端密码加密是否有意义&quot;&gt;11.web前端密码加密是否有意义？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#12平时如何管理你的项目&quot;&gt;12.平时如何管理你的项目？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;
&lt;h4 id=&quot;1-box-sizing常用的属性有哪些？分别有什么作用？&quot;&gt;&lt;a href=&quot;#1-box-sizing常用的属性有哪些？分别有什么作用？&quot; class=&quot;headerlink&quot; title=&quot;1. box-sizing常用的属性有哪些？分别有什么作用？&quot;&gt;&lt;/a&gt;1. box-sizing常用的属性有哪些？分别有什么作用？&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;属性值&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;box-sizing：content-box&lt;/li&gt;
&lt;li&gt;box-sizing：border-box&lt;/li&gt;
&lt;li&gt;box-sizing：inherit&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;content-box&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这是box-sizing的默认属性值&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="腾讯训练营" scheme="https://wtlemoney.github.io/categories/%E8%85%BE%E8%AE%AF%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
      <category term="面试" scheme="https://wtlemoney.github.io/categories/%E8%85%BE%E8%AE%AF%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="总结" scheme="https://wtlemoney.github.io/categories/%E8%85%BE%E8%AE%AF%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%9D%A2%E8%AF%95/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="blogs" scheme="https://wtlemoney.github.io/tags/blogs/"/>
    
      <category term="interview" scheme="https://wtlemoney.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>腾讯IMWeb前端训练营作业——经典面试题1</title>
    <link href="https://wtlemoney.github.io/2018/04/03/%E8%85%BE%E8%AE%AF%E9%9D%A2%E8%AF%95%E9%A2%981/"/>
    <id>https://wtlemoney.github.io/2018/04/03/腾讯面试题1/</id>
    <published>2018-04-03T14:05:53.000Z</published>
    <updated>2018-04-07T13:10:33.830Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;这些面试题是我之前参加腾讯前端训练营的时候，每天的一些面试题作业。最近自己参加暑期实习生面试的时候，也被问到过一些类似的问题。所以我整理总结了以前的面试题，通过自己搜索资料学习总结。答案有些是结合自己的理解，有些是网络上一些回答的比较好的答案，仅供参考。</p><!-- toc --><ul><li><a href="#1什么是盒子模型">1.什么是盒子模型？</a></li><li><a href="#2简述一下src与href的区别">2.简述一下src与href的区别？</a></li><li><a href="#3怎样添加-移除-移动-复制-创建和查找节点">3.怎样添加、移除、移动、复制、创建和查找节点？</a></li><li><a href="#4一次完整的http事务是怎样的一个过程">4.一次完整的HTTP事务是怎样的一个过程？</a></li><li><a href="#5你所了解的web攻击技术">5.你所了解的web攻击技术？</a></li><li><a href="#6ajax是什么ajax的交互原理同步和异步的区别">6.ajax是什么？ajax的交互原理？同步和异步的区别？</a></li><li><a href="#4什么叫优雅降级和渐进增强">4.什么叫优雅降级和渐进增强？</a></li><li><a href="#5在javascript中什么是伪数组如何将伪数组转化为标准数组">5.在JavaScript中什么是伪数组？如何将伪数组转化为标准数组？</a></li><li><a href="#6浏览器本地储存">6.浏览器本地储存？</a></li><li><a href="#7线程和进程的区别">7.线程和进程的区别？</a></li><li><a href="#8请说出三种减少页面加载时间的方法">8.请说出三种减少页面加载时间的方法？</a></li><li><a href="#9http状态码">9.HTTP状态码？</a></li><li><a href="#10请解释javascript的同源策略">10.请解释JavaScript的同源策略？</a></li><li><a href="#11get和post的区别何时使用post">11.get和post的区别，何时使用post？</a></li><li><a href="#12-对前端工程师这个职位是怎么样理解的">12. 对前端工程师这个职位是怎么样理解的？</a></li></ul><!-- tocstop --><h4><span id="1什么是盒子模型">1.什么是盒子模型？</span></h4><p><strong>两种</strong>：IE盒子模型、标准W3C盒子模型，包括content、padding、margin、border。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IE8的width=border-left+padding-left+内容宽度+padding-right+border-right;  </span><br><span class="line">IE8的height=border-top+padding-top+内容高度+padding-bottom+border-bottom; </span><br><span class="line">w3c规定的width=内容宽度; </span><br><span class="line">w3c规定的height=内容高度;</span><br></pre></td></tr></table></figure></p><p>这样有可能导致不同浏览器下获取的width或height的值不同,幸好jquery提供了另外两个方法:<a id="more"></a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">innerWidth():padding-left+内容宽度+padding-right; </span><br><span class="line">outerWidth():border-left+padding-left+内容宽度+padding-right+border-right; </span><br><span class="line">outerWidth(<span class="literal">true</span>):margin-left+border-left+padding-left+内容宽度+padding-right+border-right+margin-right;</span><br></pre></td></tr></table></figure></p><h4><span id="2简述一下src与href的区别">2.简述一下src与href的区别？</span></h4><p><strong>src</strong>指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src =<span class="string">"js.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。<br><strong>href</strong>指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果我们在文档中添加<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link href=<span class="string">"common.css"</span> rel=<span class="string">"stylesheet"</span>/&gt;</span><br></pre></td></tr></table></figure></p><p>那么浏览器会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用link方式来加载css，而不是使用@import方式。</p><h4><span id="3怎样添加-移除-移动-复制-创建和查找节点">3.怎样添加、移除、移动、复制、创建和查找节点？</span></h4><p>&emsp;1）创建新节点<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">createDocumentFragment() <span class="comment">//创建一个DOM片段</span></span><br><span class="line">createElement() <span class="comment">//创建一个具体的元素</span></span><br><span class="line">createTextNode() <span class="comment">//创建一个文本节点</span></span><br></pre></td></tr></table></figure></p><p>&emsp;2）添加、移除、替换、插入<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">appendChild() <span class="comment">//添加</span></span><br><span class="line">removeChild() <span class="comment">//移除</span></span><br><span class="line">replaceChild() <span class="comment">//替换</span></span><br><span class="line">insertBefore() <span class="comment">//之前插入</span></span><br><span class="line">insertAfter() <span class="comment">//之后插入</span></span><br><span class="line">cloneNode() <span class="comment">//复制</span></span><br></pre></td></tr></table></figure></p><p>&emsp;3）查找<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getElementsByTagName() <span class="comment">//通过标签名称</span></span><br><span class="line">getElementsByName() <span class="comment">//通过元素的Name属性的值</span></span><br><span class="line">getElementById() <span class="comment">//通过元素Id，唯一性</span></span><br><span class="line"><span class="built_in">document</span>.getElementsByClassName(<span class="string">""</span>)  <span class="comment">//通过类查找</span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">""</span>)</span><br></pre></td></tr></table></figure></p><h4><span id="4一次完整的http事务是怎样的一个过程">4.一次完整的HTTP事务是怎样的一个过程？</span></h4><p>&emsp;&emsp;当我们在浏览器的地址栏输入URL ，然后回车，回车这一瞬间到看到页面到底发生了什么呢？<br>&emsp;&emsp;域名解析 –&gt; 发起TCP的3次握手 –&gt; 建立TCP连接后发起http请求 –&gt; 服务器响应http请求，浏览器得到html代码 –&gt; 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） –&gt; 浏览器对页面进行渲染呈现给用户  </p><h4><span id="5你所了解的web攻击技术">5.你所了解的web攻击技术？</span></h4><p>&emsp;&emsp;<strong>XSS：跨站脚本攻击</strong>（Cross Site Scripting）<br>攻击者通过注入非法的html标签或者javascript代码，从而当用户浏览该网页时，控制用户浏览器。本质：内容没有过滤导致浏览器将攻击者的输入当代码执行。<br>&emsp;&emsp;<strong>CSRF：跨站点请求伪造</strong>（Cross-Site Request Forgeries）<br>冒充用户发起请求，完成一些违背用户意愿的事情（如修改用户信息，删除评论等）。本质：浏览器在发送HTTP请求时自动带上cookie，而一般网站的session都存在cookie里面。防御：get/post、验证码、请求来源限制、token等。<br>&emsp;&emsp;<strong>clickjacking：点击劫持</strong><br>利用透明的按钮或连接做成陷阱，覆盖在Web网页之上。防御：X-FRAME-OPTIONS(用来给浏览器指示允许一个页面可否在<code>&lt;frame&gt;、&lt;object&gt;</code>等中展现的标记。网站可使用此功能，确保自己网站没有被嵌到别人网站中去)</p><h4><span id="6ajax是什么ajax的交互原理同步和异步的区别">6.ajax是什么？ajax的交互原理？同步和异步的区别？</span></h4><p>&emsp;&emsp;<strong>AJAX</strong> = 异步 JavaScript 和 XML，是一种用于创建快速动态网页的技术。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。<br>&emsp;&emsp;<strong>缺点</strong>：ajax用XHR对象做出的请求不会记录在浏览器的历史中。如果你的用户习惯使用浏览器的”后退”按钮在web应用中进行导航，就可能会产生问题。另外，ajax也难以避免一些已知的安全弱点，诸如跨站点脚步攻击、SQL注入攻击和基于credentials的安全漏洞等。</p><p>&emsp;&emsp;<strong>交互原理</strong>：通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。XMLHttpRequest这个对象的属性：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">onreadystatechange 每次状态改变所触发事件的事件处理程序。</span><br><span class="line">  　　responseText       从服务器进程返回数据的字符串形式。</span><br><span class="line">  　　responseXML        从服务器进程返回的DOM兼容的文档数据对象。</span><br><span class="line">  　　status             从服务器返回的数字代码，比如常见的<span class="number">404</span>（未找到）和<span class="number">200</span>（已就绪）</span><br><span class="line">  　　status Text        伴随状态码的字符串信息</span><br><span class="line">  　　readyState         对象状态值</span><br><span class="line">　　　　<span class="number">0</span> (未初始化)      对象已建立，但是尚未初始化（尚未调用open方法）</span><br><span class="line">　　　　<span class="number">1</span> (初始化)        对象已建立，尚未调用send方法</span><br><span class="line">　　　　<span class="number">2</span> (发送数据)     send方法已调用，但是当前的状态及http头未知</span><br><span class="line">　　　　<span class="number">3</span> (数据传送中)    已接收部分数据，因为响应及http头不全，这时通过responseBody和responseText获取部分数据会出现错误</span><br><span class="line">　　　　<span class="number">4</span> (完成)         数据接收完毕,此时可以通过通过responseXml和responseText获取完整的回应数据</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;<strong>异步传输</strong>：是面向字符的传输，它的单位是字符；异步传输是将比特分成小组来进行传送。一般每个小组是一个8位字符，在每个小组的头部和尾部都有一个开始位和一个停止位，它在传送过程中接收方和发送方的时钟不要求一致，也就是说，发送方可以在任何时刻发送这些小组，而接收方并不知道它什么时候到达。<br>&emsp;&emsp;<strong>同步传输</strong>：是面向比特的传输，它的单位是桢，它传输的时候要求接受方和发送方的时钟是保持一致的。同步传输的比特分组要大得多。它不是独立地发送每个字符，每个字符都有自己的开始位和停止位，而是把它们组合起来一起发送。同步传输通常要比异步传输快速得多。接收方不必对每个字符进行开始和停止的操作。一旦检测到帧同步字符，它就在接下来的数据到达时接收它们。另外，同步传输的开销也比较少。   </p><h4><span id="4什么叫优雅降级和渐进增强">4.什么叫优雅降级和渐进增强？</span></h4><p>&emsp;&emsp;<strong>优雅降级</strong>：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了,为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效.<br>&emsp;&emsp;<strong>渐进增强</strong>：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。</p><h4><span id="5在javascript中什么是伪数组如何将伪数组转化为标准数组">5.在JavaScript中什么是伪数组？如何将伪数组转化为标准数组？</span></h4><p>&emsp;&emsp;<strong>伪数组</strong>（类数组）：无法直接调用数组方法或期望length属性有什么特殊的行为，但仍可以用真正数组的遍历方法遍历它们。典型的是函数的argument参数，还有像调用<code>getElementByTagName</code>,<code>document.childNodes</code>之类的，它们都返回NodeList对象都属于伪数组。<br>&emsp;&emsp;可以通过Array.prototype.slice.call(fakeArray)将伪数组转化为真正的Array对象。</p><h4><span id="6浏览器本地储存">6.浏览器本地储存？</span></h4><p>&emsp;&emsp;在 HTML5 中提供了 sessionStorage 和 localStorage 。<br>&emsp;&emsp;<strong>sessionStorage</strong>：用于本地存储一个会话（ session ）中的数据，这些数据只有在同一个会话中的页面才能访问，会话结束后数据随之销毁。因此它不是一种持久化的本地存储，仅仅是会话级别的存储。<br>&emsp;&emsp;<strong>localStorage</strong>：用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。IE8及以上都兼容。<br>&emsp;&emsp;<strong>cookie</strong>：当用户访问了某个网站（网页）时，我们就可通过cookie来向访问者电脑上存储数据。或者，某些网站为了辨别用户身份，进行session跟踪而存储在用户本地终端上的数据（加密）。cookie值既可以设置，也可以读取。如何工作：1）当网页要发http请求时，浏览器会先检查是否有相应的cookie，有则自动添加在request header中的字段中。2）对于那种设置“每次请求都要携带的信息”（最典型：身份认证信息）特别适合放在cookie中，其他类型的数据就不适合了。</p><h4><span id="7线程和进程的区别">7.线程和进程的区别？</span></h4><p>&emsp;&emsp;进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。以多进程形式，允许多个任务同时运行；以多线程形式，允许单个任务分成不同的部分运行；</p><h4><span id="8请说出三种减少页面加载时间的方法">8.请说出三种减少页面加载时间的方法？</span></h4><p>&emsp;&emsp;1）优化图片<br>&emsp;&emsp;2）图像格式的选择（GIF：提供的颜色较少，可用在一些对颜色要求不高的地方）<br>&emsp;&emsp;3）优化CSS（压缩合并css，如 margin-top, margin-left…)<br>&emsp;&emsp;4）网址后加斜杠（如<a href="http://www.campr.com/目录，会判断这个目录是什么文件类型，或者是目录。）" target="_blank" rel="noopener">www.campr.com/目录，会判断这个目录是什么文件类型，或者是目录。）</a><br>&emsp;&emsp;5）标明高度和宽度（如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小，如果图片很多，浏览器需要不断地调整页面。这不但影响速度，也影响浏览体验。当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加载后面的内容。从而加载时间快了，浏览体验也更好了）<br>&emsp;&emsp;6）减少http请求（合并文件，合并图片）CSS精灵，将JS代码写在body后面</p><h4><span id="9http状态码">9.HTTP状态码？</span></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>xx: 信息性状态码，表示服务器接收到请求正在处理。</span><br><span class="line"><span class="number">2</span>xx: 成功状态码，表示服务器正确处理完请求。</span><br><span class="line"><span class="number">3</span>xx: 重定向状态码，表示请求的资源位置发生改变，需要重新请求。<span class="number">301</span>永久重定向，<span class="number">302</span>临时重定向。</span><br><span class="line"><span class="number">4</span>xx: 客户端错误状态码，服务器无法处理该请求。 <span class="number">404</span> not found</span><br><span class="line"><span class="number">5</span>xx: 服务器错误状态码，服务器处理请求出错。</span><br><span class="line"></span><br><span class="line"><span class="number">100</span> Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息</span><br><span class="line"><span class="number">200</span> OK 正常返回信息</span><br><span class="line"><span class="number">201</span> Created 请求成功并且服务器创建了新的资源</span><br><span class="line"><span class="number">202</span> Accepted 服务器已接受请求，但尚未处理</span><br><span class="line"><span class="number">301</span> Moved Permanently 请求的网页已永久移动到新位置</span><br><span class="line"><span class="number">302</span> Found 临时性重定向</span><br><span class="line"><span class="number">303</span> See Other 临时性重定向，且总是使用 GET 请求新的 URI</span><br><span class="line"><span class="number">304</span> Not Modified 自从上次请求后，请求的网页未修改过</span><br><span class="line"><span class="number">400</span> Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求</span><br><span class="line"><span class="number">401</span> Unauthorized 请求未授权</span><br><span class="line"><span class="number">403</span> Forbidden 禁止访问</span><br><span class="line"><span class="number">404</span> Not Found 找不到如何与 URI 相匹配的资源</span><br><span class="line"><span class="number">500</span> Internal Server <span class="built_in">Error</span> 最常见的服务器端错误</span><br><span class="line"><span class="number">503</span> Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）</span><br></pre></td></tr></table></figure><h4><span id="10请解释javascript的同源策略">10.请解释JavaScript的同源策略？</span></h4><p>&emsp;&emsp;<strong>同源策略</strong>是客户端脚本（尤其是Javascript）的重要的安全度量标准，目的是防止某个文档或脚本从多个不同源装载。同源策略：协议，域名，端口相同，它是一种安全协议，指一段脚本只能读取来自同一来源的窗口和文档的属性，无法访问其它域的资源。</p><h4><span id="11get和post的区别何时使用post">11.get和post的区别，何时使用post？</span></h4><p>&emsp;&emsp;<strong>GET</strong>：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符<br>&emsp;&emsp;<strong>POST</strong>：一般用于修改服务器上的资源，对所发送的信息没有限制<br>&emsp;&emsp;HTTP中的GET，POST，PUT，DELETE就对应着对这个资源的查，改，增，删4个操作。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息。<br>&emsp;&emsp;在以下情况中，请使用 POST 请求：<br>&emsp;&emsp;1）无法使用缓存文件（更新服务器上的文件或数据库）<br>&emsp;&emsp;2）向服务器发送大量数据（POST 没有数据量限制）<br>&emsp;&emsp;3）发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠<br>&emsp;&emsp;安全性：<br>&emsp;&emsp;1）GET不会修改服务端数据，POST可以修改数据<br>&emsp;&emsp;2）URL方式发起GET请求，参数会明文暴露<br>&emsp;&emsp;3）使用GET提交数据还可能会造成Cross-site request forgery攻击<br>&emsp;&emsp;4）本质上安全性无区别</p><h4><span id="12-对前端工程师这个职位是怎么样理解的">12. 对前端工程师这个职位是怎么样理解的？</span></h4><p>前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。</p><ul><li><p>实现界面交互</p></li><li><p>提升用户体验</p></li><li><p>有了Node.js，前端可以实现服务端的一些事情</p></li><li><p>前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好</p></li><li><p>参与项目，快速高质量完成实现效果图，精确到1px</p></li><li><p>与团队成员，UI设计，产品经理的沟通</p></li><li><p>做好的页面结构，页面重构和用户体验</p></li><li><p>处理hack，兼容、写出优美的代码格式</p></li><li><p>针对服务器的优化、拥抱最新前端技术</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;这些面试题是我之前参加腾讯前端训练营的时候，每天的一些面试题作业。最近自己参加暑期实习生面试的时候，也被问到过一些类似的问题。所以我整理总结了以前的面试题，通过自己搜索资料学习总结。答案有些是结合自己的理解，有些是网络上一些回答的比较好的答案，仅供参考。&lt;/p&gt;
&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1什么是盒子模型&quot;&gt;1.什么是盒子模型？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2简述一下src与href的区别&quot;&gt;2.简述一下src与href的区别？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3怎样添加-移除-移动-复制-创建和查找节点&quot;&gt;3.怎样添加、移除、移动、复制、创建和查找节点？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#4一次完整的http事务是怎样的一个过程&quot;&gt;4.一次完整的HTTP事务是怎样的一个过程？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#5你所了解的web攻击技术&quot;&gt;5.你所了解的web攻击技术？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#6ajax是什么ajax的交互原理同步和异步的区别&quot;&gt;6.ajax是什么？ajax的交互原理？同步和异步的区别？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#4什么叫优雅降级和渐进增强&quot;&gt;4.什么叫优雅降级和渐进增强？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#5在javascript中什么是伪数组如何将伪数组转化为标准数组&quot;&gt;5.在JavaScript中什么是伪数组？如何将伪数组转化为标准数组？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#6浏览器本地储存&quot;&gt;6.浏览器本地储存？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#7线程和进程的区别&quot;&gt;7.线程和进程的区别？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#8请说出三种减少页面加载时间的方法&quot;&gt;8.请说出三种减少页面加载时间的方法？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#9http状态码&quot;&gt;9.HTTP状态码？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#10请解释javascript的同源策略&quot;&gt;10.请解释JavaScript的同源策略？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#11get和post的区别何时使用post&quot;&gt;11.get和post的区别，何时使用post？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#12-对前端工程师这个职位是怎么样理解的&quot;&gt;12. 对前端工程师这个职位是怎么样理解的？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;
&lt;h4 id=&quot;1-什么是盒子模型？&quot;&gt;&lt;a href=&quot;#1-什么是盒子模型？&quot; class=&quot;headerlink&quot; title=&quot;1.什么是盒子模型？&quot;&gt;&lt;/a&gt;1.什么是盒子模型？&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;两种&lt;/strong&gt;：IE盒子模型、标准W3C盒子模型，包括content、padding、margin、border。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;IE8的width=border-left+padding-left+内容宽度+padding-right+border-right;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;IE8的height=border-top+padding-top+内容高度+padding-bottom+border-bottom; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;w3c规定的width=内容宽度; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;w3c规定的height=内容高度;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这样有可能导致不同浏览器下获取的width或height的值不同,幸好jquery提供了另外两个方法:&lt;/p&gt;
    
    </summary>
    
      <category term="腾讯训练营" scheme="https://wtlemoney.github.io/categories/%E8%85%BE%E8%AE%AF%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
      <category term="面试" scheme="https://wtlemoney.github.io/categories/%E8%85%BE%E8%AE%AF%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="总结" scheme="https://wtlemoney.github.io/categories/%E8%85%BE%E8%AE%AF%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%9D%A2%E8%AF%95/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="blogs" scheme="https://wtlemoney.github.io/tags/blogs/"/>
    
      <category term="interview" scheme="https://wtlemoney.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript之处理数组</title>
    <link href="https://wtlemoney.github.io/2018/04/02/%E6%95%B0%E7%BB%84/"/>
    <id>https://wtlemoney.github.io/2018/04/02/数组/</id>
    <published>2018-04-01T16:38:49.000Z</published>
    <updated>2018-04-18T06:11:59.555Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;哈哈，看似是些简单的处理数组的函数，但是由于平时码的少，实习生笔试的时候走了弯路吃了亏啊，写的很慢呀。。。有些是忘记了，有些是参数和返回值记忆模糊了，所以多码码，总结总结。持续更新中…<a id="more"></a></p><!-- toc --><ul><li><a href="#1数组的创建">1.数组的创建</a></li><li><a href="#2数组的检测">2.数组的检测</a></li><li><a href="#3数组的方法">3.数组的方法</a><ul><li><a href="#splice">splice()</a></li><li><a href="#slice">slice()</a></li><li><a href="#filter">filter()</a></li><li><a href="#map">map()</a></li><li><a href="#reduce">reduce()</a></li><li><a href="#reduceright">reduceRight()</a></li><li><a href="#every">every()</a></li><li><a href="#some">some()</a></li><li><a href="#pop">pop()</a></li><li><a href="#shift">shift()</a></li><li><a href="#unshift">unshift()</a></li><li><a href="#push">push()</a></li><li><a href="#reverse">reverse()</a></li><li><a href="#sort">sort()</a></li><li><a href="#tostring">toString()</a></li><li><a href="#concat">concat()</a></li><li><a href="#join">join()</a></li><li><a href="#indexoflastindexof">indexOf(),lastIndexOf()</a></li><li><a href="#foreach">forEach()</a></li><li><a href="#fill">fill()</a></li><li><a href="#findfindindex">find()/findIndex()</a></li><li><a href="#copywithin">copyWithin()</a></li><li><a href="#includes">includes()</a></li></ul></li><li><a href="#4构造函数的方法">4.构造函数的方法</a><ul><li><a href="#arrayfrom">Array.from()</a></li></ul></li></ul><!-- tocstop --><h3><span id="1数组的创建">1.数组的创建</span></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数方式，new可以省略</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(); <span class="comment">// 创建空数组</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>); <span class="comment">// 创建长度为10的数组</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">'a'</span>); <span class="comment">// ['a']</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>, <span class="string">'a'</span>); <span class="comment">// [10,'a']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字面量方式</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">10</span>, <span class="string">'a'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//Array.of(),ES6新增</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.of(<span class="number">1</span>); <span class="comment">// [1]</span></span><br><span class="line"><span class="keyword">let</span> arr1 = <span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="string">'a'</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, &#123;<span class="attr">name</span>: <span class="string">"zhangsan"</span>&#125;, [<span class="number">45</span>]); <span class="comment">// [ 1, 'a', true, null, undefined, &#123; name: 'zhangsan' &#125;, [ 45 ] ]</span></span><br></pre></td></tr></table></figure><h3><span id="2数组的检测">2.数组的检测</span></h3><ul><li>toString()<br>  <code>Object.prototype.toString.call([])===&quot;object Array&quot;;//true</code></li><li>Array.isArray()<br>  <code>Array,isArray([1,&#39;a&#39;,null]);//true</code>;</li></ul><h3><span id="3数组的方法">3.数组的方法</span></h3><h4><span id="splice">splice()</span></h4><p>返回值：被删除的元素数组<br>原数组是否改变：是<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="string">'a'</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="string">'d'</span>];</span><br><span class="line">arr.splice(<span class="number">1</span>,<span class="number">2</span>,<span class="string">'b'</span>,<span class="string">'c'</span>);<span class="comment">//[4,5]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//["a", "b", "c", "d"]</span></span><br></pre></td></tr></table></figure></p><h4><span id="slice">slice()</span></h4><p>返回值：截取的元素组成的数组<br>原数组是否改变：否<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>];</span><br><span class="line">arr.slice(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//['b']</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//["a", "b", "c", "d"]</span></span><br></pre></td></tr></table></figure></p><!-- more -->    <h4><span id="filter">filter()</span></h4><p>返回值：新的数组<br>原数组是否改变：否<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBigEnough</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value&gt;=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr=[<span class="number">12</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">130</span>,<span class="number">44</span>];</span><br><span class="line">arr.filter(isBigEnough);<span class="comment">//[12,130,44]</span></span><br></pre></td></tr></table></figure></p><h4><span id="map">map()</span></h4><p>返回值：新的数组<br>原数组是否改变：否<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> res=arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x*x;</span><br><span class="line">&#125;);<span class="comment">//res=[1,4,9]</span></span><br></pre></td></tr></table></figure></p><h4><span id="reduce">reduce()</span></h4><p>原数组是否改变：否<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> res=arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;);<span class="comment">//res=15</span></span><br></pre></td></tr></table></figure></p><h4><span id="reduceright">reduceRight()</span></h4><p>从数组的最后一项开始，逐步遍历到第一项，迭代数组的所有项<br>返回值：数组迭代后，整体的迭代结果<br>原数组是否改变：否<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拼接字符串,从后向前迭代数组进行拼接</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>];</span><br><span class="line"><span class="keyword">let</span> str = arr.reduceRight(<span class="function">(<span class="params">prev, cur, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> prev + cur;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr, str); <span class="comment">// [ 'h', 'e', 'l', 'l', 'o' ] 'olleh'</span></span><br></pre></td></tr></table></figure></p><h4><span id="every">every()</span></h4><p>判断arr是否都满足x&gt;=18的条件<br>返回值：true或false<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> arr=[<span class="number">12</span>,<span class="number">34</span>,<span class="number">56</span>];</span><br><span class="line">    <span class="keyword">var</span> res=arr.every(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x&gt;=<span class="number">18</span>;</span><br><span class="line">    &#125;);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法的第二个参数可选，作用是设定第一个参数中的this指向，如果使用第二个参数，注意callback不能是箭头函数</span></span><br><span class="line"><span class="comment">// 迭代方法涉及此参数的，用法相同</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> temp = arr.every(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item &gt; <span class="keyword">this</span>.id;</span><br><span class="line">&#125;, &#123;<span class="attr">id</span>: <span class="number">2</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr, temp); <span class="comment">// [ 1, 2, 3, 4 ] false</span></span><br></pre></td></tr></table></figure></p><h4><span id="some">some()</span></h4><p>判断是否有满足条件的<br>返回值：true或false<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">12</span>,<span class="number">34</span>,<span class="number">56</span>];</span><br><span class="line"><span class="keyword">var</span> res=arr.some(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&gt;=<span class="number">18</span>;</span><br><span class="line">&#125;);<span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><h4><span id="pop">pop()</span></h4><p>返回值：最后一个元素(栈顶元素)<br>原数组是否改变：是<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr.pop();<span class="comment">//3</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//[1,2]</span></span><br></pre></td></tr></table></figure></p><h4><span id="shift">shift()</span></h4><p>返回值：第一个元素(栈底元素)<br>原数组是否改变：是<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr.shift();<span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//[2,3]</span></span><br></pre></td></tr></table></figure></p><h4><span id="unshift">unshift()</span></h4><p>返回值：添加元素后数组的长度<br>原数组是否改变：是<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr.unshift(<span class="string">'a'</span>);<span class="comment">//4</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//['a',1,2,3]</span></span><br></pre></td></tr></table></figure></p><h4><span id="push">push()</span></h4><p>返回值：添加元素后数组的长度<br>原数组是否改变：是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=[<span class="number">2</span>,<span class="string">'a'</span>,<span class="string">'b'</span>];</span><br><span class="line"><span class="keyword">let</span> temp=arr.push(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr,temp);<span class="comment">//[2,'a','b',3,4] 5</span></span><br></pre></td></tr></table></figure><h4><span id="reverse">reverse()</span></h4><p>返回值：翻转后的数组<br>原数组是否改变：是  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> temp = arr.reverse();</span><br><span class="line"><span class="built_in">console</span>.log(arr, temp); <span class="comment">// [ 3, 2, 1 ] [ 3, 2, 1 ]</span></span><br></pre></td></tr></table></figure><h4><span id="sort">sort()</span></h4><p>返回值：排序后的数组<br>原数组是否改变：是<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 数组从小到大排序</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> temp = arr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr, temp); <span class="comment">// [ 1, 2, 3, 4, 6, 7, 8 ] [ 1, 2, 3, 4, 6, 7, 8 ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个实用的数组排序的例子，根据对象元素的排序，排序对象在数组中的位置</span></span><br><span class="line"><span class="keyword">let</span> objArr = [&#123;<span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">"lilei"</span>&#125;,&#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">"hanmeimei"</span>&#125;,&#123;<span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">"yimi"</span>&#125;];</span><br><span class="line"><span class="keyword">let</span> tempArr = objArr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 按照id从小到大的顺序，对数组中的对象进行排序</span></span><br><span class="line">    <span class="comment">// 这个示例说明回调函数的形参a,b实际就是数组中当前进行比对的两个元素</span></span><br><span class="line">    <span class="keyword">return</span> a.id - b.id;</span><br><span class="line">&#125;); </span><br><span class="line"><span class="built_in">console</span>.log(objArr); <span class="comment">//  [&#123;id: 1, name: 'hanmeimei'&#125;, &#123;id: 2, name: 'yimi'&#125;, &#123; id: 3, name: 'lilei' &#125;]</span></span><br><span class="line"><span class="built_in">console</span>.log(tempArr); <span class="comment">// [&#123;id: 1, name: 'hanmeimei'&#125;, &#123;id: 2, name: 'yimi'&#125;, &#123; id: 3, name: 'lilei'&#125;]</span></span><br></pre></td></tr></table></figure></p><h4><span id="tostring">toString()</span></h4><p>返回值：以逗号分隔de字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].toString();<span class="comment">//"1,2,3"</span></span><br><span class="line">[<span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">4</span>]], &#123;<span class="attr">name</span>: <span class="string">"zhangsan"</span>&#125;, <span class="number">3</span>].toString();<span class="comment">//'1,1,2,4,[object Object],3'</span></span><br></pre></td></tr></table></figure><h4><span id="concat">concat()</span></h4><p>返回值：拼接后的数组<br>原数组是否改变：否</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> temp = arr.concat(<span class="string">'a'</span>, &#123;<span class="attr">id</span>:<span class="number">1</span>&#125;, [<span class="string">'lilei'</span>, <span class="string">'hanmeimei'</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(arr, temp); <span class="comment">// [ 1, 2 ] [ 1, 2, 'a', &#123; id: 1 &#125;, 'lilei', 'hanmeimei']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于复制数组</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> temp = arr.concat();</span><br><span class="line"><span class="built_in">console</span>.log(arr, temp);  <span class="comment">// [ 1, 2 ] [ 1, 2 ]</span></span><br></pre></td></tr></table></figure><h4><span id="join">join()</span></h4><p>返回值：拼接后的字符串<br>原数组是否改变：否<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">4</span>]], &#123;<span class="attr">name</span>: <span class="string">"zhangsan"</span>&#125;, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> temp = arr.join();</span><br><span class="line"><span class="built_in">console</span>.log(arr, temp); <span class="comment">// '1,1,2,4,[object Object],3'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数组求和</span></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">eval</span>(arr1.join(<span class="string">'+'</span>))); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure></p><h4><span id="indexoflastindexof">indexOf(),lastIndexOf()</span></h4><p>返回值：找到返回索引值，否则返回-1<br>原数组是否改变：否<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>];</span><br><span class="line"><span class="comment">// 从数组开头开始查找</span></span><br><span class="line"><span class="keyword">let</span> temp = arr.indexOf(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr, temp); <span class="comment">// [ 1, 2, 3, 4, 5, 6, 2 ] 1</span></span><br><span class="line"><span class="comment">// 从指定的位置开始查找</span></span><br><span class="line"><span class="keyword">let</span> temp1 = arr.indexOf(<span class="number">2</span>,<span class="number">3</span>); <span class="comment">// 从索引3(包括)的位置向后查找元素2</span></span><br><span class="line"><span class="built_in">console</span>.log(arr, temp1); <span class="comment">// [ 1, 2, 3, 4, 5, 6, 2 ] 6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>];</span><br><span class="line"><span class="comment">// 从数组末尾开始查找</span></span><br><span class="line"><span class="keyword">let</span> temp = arr.lastIndexOf(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr, temp); <span class="comment">// [ 1, 2, 3, 4, 5, 6, 2 ] 6</span></span><br><span class="line"><span class="comment">// 从指定的位置开始查找</span></span><br><span class="line"><span class="keyword">let</span> temp1 = arr.lastIndexOf(<span class="number">2</span>,<span class="number">3</span>); <span class="comment">// 从索引3(包括)的位置向前查找元素2</span></span><br><span class="line"><span class="built_in">console</span>.log(arr, temp1); <span class="comment">// [ 1, 2, 3, 4, 5, 6, 2 ] 1</span></span><br></pre></td></tr></table></figure></p><h4><span id="foreach">forEach()</span></h4><p>forEach在所有项都遍历完成之前，无法像for循环一样提前终止循环<br>返回值：无<br>原数组是否改变：否<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> temp = arr.forEach(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 不会有返回值，但可在这里执行某些操作</span></span><br><span class="line">    <span class="keyword">return</span> item * item;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr, temp); <span class="comment">// [ 1, 2, 3, 4 ] undefined</span></span><br></pre></td></tr></table></figure></p><h4><span id="fill">fill()</span></h4><p>ES6新增<br>作用：用指定元素，填充数组从start(包括)到end（不包括）之间的元素，如果该区间内已经有元素，直接替换掉（ES6新增）<br>参数：value[, start[, end]]<br>返回值：填充后的数组<br>原数组是否改变：是<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> temp = arr.fill(<span class="string">'a'</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr, temp); <span class="comment">// [1, 2, 'a', 'a', 5] [1, 2, 'a', 'a', 5]</span></span><br></pre></td></tr></table></figure></p><h4><span id="findfindindex">find()/findIndex()</span></h4><p>find()为ES6新增<br>作用：查找数组中第一个符合条件的元素所在位置的索引，并返回该索引值<br>参数：callback[, thisArg]<br>参数说明：参数的使用同forEach、every、map、some、filter方法一致<br>返回值：找到返回该索引值，没找到返回undefined/-1<br>原数组是否改变：否<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> temp = arr.findIndex(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item &gt; <span class="number">2</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr, temp); <span class="comment">// [1, 2, 3, 4, 5] 2</span></span><br></pre></td></tr></table></figure></p><h4><span id="copywithin">copyWithin()</span></h4><p>ES6新增<br>作用：在数组长度的范围内，复制start(包括)到end(不包括)范围内的元素，换掉从target（包括）开始到数组结尾的元素，能替换多少就替换多少<br>参数说明：target[,start[,end]]</p><ul><li>target: 复制的目标位置（包括），即要被替换的元素开始的位置</li><li>start: 要copy的元素的开始位置，默认0</li><li>end: 要copy的元素的结束位置，默认为数组最后一个元素<br>返回值：复制替换之后的数组<br>原数组是否改变：是  </li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> temp = arr.copyWithin(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr, temp); <span class="comment">//  [1, 2, 3, 1, 2] [1, 2, 3, 1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> temp1 = arr1.copyWithin(<span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr1, temp1); <span class="comment">// [1, 2, 3, 3, 4] [1, 2, 3, 3, 4]</span></span><br></pre></td></tr></table></figure><h4><span id="includes">includes()</span></h4><p>ES7新增<br>返回值：true或false<br>原数组是否改变：否<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> temp = arr.includes(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr, temp); <span class="comment">// [1, 2, 3, 4, 5] true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个方法弥补了indexOf查看元素时的一个不足，即查找NaN的误差</span></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="literal">NaN</span>, <span class="string">'a'</span>];</span><br><span class="line"><span class="keyword">let</span> temp1 = arr1.includes(<span class="literal">NaN</span>);</span><br><span class="line"><span class="keyword">let</span> temp2 = arr1.indexOf(<span class="literal">NaN</span>);</span><br><span class="line"><span class="built_in">console</span>.log(temp1, temp2); <span class="comment">//true -1</span></span><br></pre></td></tr></table></figure></p><h3><span id="4构造函数的方法">4.构造函数的方法</span></h3><h4><span id="arrayfrom">Array.from()</span></h4><p>Array.from() 等价于 <code>Array.prototype.slice.call(arguments,0)</code><br>返回值：转化后的数组<br>原类数组是否改变：否<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'hello'</span>;</span><br><span class="line"><span class="keyword">let</span> temp = <span class="built_in">Array</span>.from(str);</span><br><span class="line"><span class="built_in">console</span>.log(str, temp); <span class="comment">// hello [ 'h', 'e', 'l', 'l', 'o' ]</span></span><br><span class="line"><span class="keyword">let</span> temp1 = <span class="built_in">Array</span>.from(str, (item, index, arr) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> item.toUpperCase();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(str, temp1); <span class="comment">// hello [ 'H', 'E', 'L', 'L', 'O' ]</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;哈哈，看似是些简单的处理数组的函数，但是由于平时码的少，实习生笔试的时候走了弯路吃了亏啊，写的很慢呀。。。有些是忘记了，有些是参数和返回值记忆模糊了，所以多码码，总结总结。持续更新中…&lt;/p&gt;
    
    </summary>
    
      <category term="数组" scheme="https://wtlemoney.github.io/categories/%E6%95%B0%E7%BB%84/"/>
    
      <category term="函数" scheme="https://wtlemoney.github.io/categories/%E6%95%B0%E7%BB%84/%E5%87%BD%E6%95%B0/"/>
    
      <category term="ES6" scheme="https://wtlemoney.github.io/categories/%E6%95%B0%E7%BB%84/%E5%87%BD%E6%95%B0/ES6/"/>
    
    
      <category term="JavaScript" scheme="https://wtlemoney.github.io/tags/JavaScript/"/>
    
      <category term="array" scheme="https://wtlemoney.github.io/tags/array/"/>
    
      <category term="function" scheme="https://wtlemoney.github.io/tags/function/"/>
    
  </entry>
  
  <entry>
    <title>作用域闭包</title>
    <link href="https://wtlemoney.github.io/2018/03/30/%E9%97%AD%E5%8C%85/"/>
    <id>https://wtlemoney.github.io/2018/03/30/闭包/</id>
    <published>2018-03-30T12:48:11.000Z</published>
    <updated>2018-04-19T11:33:43.556Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#1-什么是闭包">1. 什么是闭包？</a></li><li><a href="#2-循环和闭包">2. 循环和闭包</a></li><li><a href="#3-闭包的好处">3. 闭包的好处</a><ul><li><a href="#31-减少局部变量">3.1 减少局部变量</a></li><li><a href="#32-减少传递给函数的参数变量">3.2 减少传递给函数的参数变量</a></li><li><a href="#33-封装">3.3 封装</a></li></ul></li></ul><!-- tocstop --><h4><span id="1-什么是闭包">1. 什么是闭包？</span></h4><p>&emsp;&emsp;OK,来看下面一段能清晰展示闭包的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> a=<span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> baz=foo();</span><br><span class="line">baz();<span class="comment">//2</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><p>&emsp;&emsp;闭包使得函数bar()可以继续访问定义时的词法作用域。函数能被外部调用到，则该作用域链上的所有变量都会被保存下来。  </p><blockquote><ul><li>定义：包就是能够读取其他函数内部变量的函数。由于在JavaScript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解为“定义在一个函数内部的函数”。</li><li>本质：闭包是将函数内部和外部连接起来的桥梁。</li><li>用处：一是可以读取函数内部的变量；二是让这些变量的值始终保持在内存中。</li><li>注意点：<br>&emsp;&emsp;&emsp;1）不能滥用闭包<br>&emsp;&emsp;由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能会导致内存泄漏。<br>&emsp;&emsp;解决方法：在退出函数之前，将不使用的局部变量全部删除。<br>&emsp;&emsp;&emsp;2）不要随便改变父函数内部变量的值。<br>&emsp;&emsp;把父函数当作对象使用，闭包当作它的公有方法，内部变量当作它的私有属性，闭包会在父函数外部，改变父函数变量的值，所以要注意。  </li></ul></blockquote><h4><span id="2-循环和闭包">2. 循环和闭包</span></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;,i*<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;正常情况下，这段代码预期会分别输出数字1-5，每秒一次，每次一个(注意是i*1000,不是1000)。但实际上，这段代码会以每秒一次的频率输出五次6(如果是1000，五个6会同一时间输出)！这是因为：循环的终止条件是i=6，而延迟函数的回调会在循坏结束时在执行。<br>&emsp;&emsp;试一下这样可以输出预期的1-5吗：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">      (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(i);</span><br><span class="line">      &#125;,i*<span class="number">1000</span>);</span><br><span class="line">&#125;)();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;答案是不行！这样每个延迟函数确实将立即执行函数在每次迭代中创建的作用域封闭起来，但是作用域是空的，所以它需要有自己的变量，用来在迭代中储存i的值。像下面这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">      (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> j=i;</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(j);</span><br><span class="line">      &#125;,j*<span class="number">1000</span>);</span><br><span class="line">&#125;)();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;可以对上面的代码进行改进：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">      (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>)</span>&#123;<span class="comment">//将i传递进来，将变量名定为j，当然也可以还叫作i</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(j);</span><br><span class="line">      &#125;,j*<span class="number">1000</span>);</span><br><span class="line">&#125;)(i);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;块作用域和闭包联手，听说天下无敌，不信你看：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(j);</span><br><span class="line">   &#125;,j*<span class="number">1000</span>);<span class="comment">//程序员的快乐</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4><span id="3-闭包的好处">3. 闭包的好处</span></h4><h5><span id="31-减少局部变量">3.1 减少局部变量</span></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;a++;alert(a);&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result=f();</span><br><span class="line">result();<span class="comment">//1</span></span><br><span class="line">result();<span class="comment">//2</span></span><br></pre></td></tr></table></figure><h5><span id="32-减少传递给函数的参数变量">3.2 减少传递给函数的参数变量</span></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calFactory</span>(<span class="params">base</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">max</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> total=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=max;i++)&#123;</span><br><span class="line">            total+=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total+base;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> adder=calFactory(<span class="number">2</span>);</span><br><span class="line">adder(<span class="number">3</span>);<span class="comment">//8</span></span><br></pre></td></tr></table></figure><h5><span id="33-封装">3.3 封装</span></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> m=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getM</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> m;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setM</span>(<span class="params">val</span>)</span>&#123;m=val;&#125;</span><br><span class="line">    <span class="built_in">window</span>.g=getM;</span><br><span class="line">    <span class="built_in">window</span>.f=setM;</span><br><span class="line">&#125;)();</span><br><span class="line">f(<span class="number">12</span>);</span><br><span class="line">alert(g());<span class="comment">//12</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-什么是闭包&quot;&gt;1. 什么是闭包？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-循环和闭包&quot;&gt;2. 循环和闭包&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3-闭包的好处&quot;&gt;3. 闭包的好处&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#31-减少局部变量&quot;&gt;3.1 减少局部变量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#32-减少传递给函数的参数变量&quot;&gt;3.2 减少传递给函数的参数变量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#33-封装&quot;&gt;3.3 封装&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;
&lt;h4 id=&quot;1-什么是闭包？&quot;&gt;&lt;a href=&quot;#1-什么是闭包？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是闭包？&quot;&gt;&lt;/a&gt;1. 什么是闭包？&lt;/h4&gt;&lt;p&gt;&amp;emsp;&amp;emsp;OK,来看下面一段能清晰展示闭包的代码：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a=&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;bar&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(a);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; bar;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; baz=foo();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;baz();&lt;span class=&quot;comment&quot;&gt;//2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="闭包" scheme="https://wtlemoney.github.io/categories/%E9%97%AD%E5%8C%85/"/>
    
      <category term="你不知道的JavaScript" scheme="https://wtlemoney.github.io/categories/%E9%97%AD%E5%8C%85/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://wtlemoney.github.io/tags/JavaScript/"/>
    
      <category term="blogs" scheme="https://wtlemoney.github.io/tags/blogs/"/>
    
      <category term="闭包" scheme="https://wtlemoney.github.io/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>变量提升</title>
    <link href="https://wtlemoney.github.io/2018/03/29/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/"/>
    <id>https://wtlemoney.github.io/2018/03/29/变量提升/</id>
    <published>2018-03-28T16:25:38.000Z</published>
    <updated>2018-04-19T11:33:07.708Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#1-先有鸡还是先有蛋">1. 先有鸡还是先有蛋</a></li><li><a href="#2-函数优先">2. 函数优先</a></li></ul><!-- tocstop --><h4><span id="1-先有鸡还是先有蛋">1. 先有鸡还是先有蛋</span></h4><p>&emsp;&emsp;来看下面两段代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//2</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="keyword">var</span> a=<span class="number">2</span>;<span class="comment">//undefined,不是ReferenceError!</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;实际上，包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。所以，先有蛋（声明）后有鸡（赋值）。只有声明本身会提升，而赋值或其他运行逻辑会留在原地。<br><br>&emsp;&emsp;注意：函数声明会被提升，但是函数表达式不会提升。看下面：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);<span class="comment">//undefined</span></span><br><span class="line">    <span class="keyword">var</span> a=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo();<span class="comment">//不是ReferenceError,而是TypeError!</span></span><br><span class="line"><span class="keyword">var</span> foo=<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;foo()由于对undefined值进行函数调用而导致非法操作，因此抛出TypeError异常！</p><h4><span id="2-函数优先">2. 函数优先</span></h4><p>&emsp;&emsp;有多个“重复”声明的代码中，函数首先被提升，然后才是变量：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">foo();<span class="comment">//1</span></span><br><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;会输出1而不是2！这个代码会被引擎理解为如下形式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();<span class="comment">//1</span></span><br><span class="line">foo=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;所以，要避免重复声明，特别是当普通的var声明和函数声明混合在一起的时候，否则会引起很多危险的问题！<br>&emsp;&emsp;尽管重复的var声明会被会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">foo();<span class="comment">//3</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;需要注意的是，尽可能避免在块内部声明函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">foo();<span class="comment">//'b'</span></span><br><span class="line"><span class="keyword">var</span> a=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(a)&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"a"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"a"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-先有鸡还是先有蛋&quot;&gt;1. 先有鸡还是先有蛋&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-函数优先&quot;&gt;2. 函数优先&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;
&lt;h4 id=&quot;1-先有鸡还是先有蛋&quot;&gt;&lt;a href=&quot;#1-先有鸡还是先有蛋&quot; class=&quot;headerlink&quot; title=&quot;1. 先有鸡还是先有蛋&quot;&gt;&lt;/a&gt;1. 先有鸡还是先有蛋&lt;/h4&gt;&lt;p&gt;&amp;emsp;&amp;emsp;来看下面两段代码&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;a=&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(a);&lt;span class=&quot;comment&quot;&gt;//2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="你不知道的JavaScript" scheme="https://wtlemoney.github.io/categories/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript/"/>
    
      <category term="函数" scheme="https://wtlemoney.github.io/categories/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript/%E5%87%BD%E6%95%B0/"/>
    
    
      <category term="JavaScript" scheme="https://wtlemoney.github.io/tags/JavaScript/"/>
    
      <category term="blogs" scheme="https://wtlemoney.github.io/tags/blogs/"/>
    
      <category term="变量" scheme="https://wtlemoney.github.io/tags/%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>this的指向问题</title>
    <link href="https://wtlemoney.github.io/2018/03/27/this%E7%9A%84%E6%8C%87%E5%90%91/"/>
    <id>https://wtlemoney.github.io/2018/03/27/this的指向/</id>
    <published>2018-03-27T11:06:24.000Z</published>
    <updated>2018-04-19T11:31:41.163Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#1-this的绑定规则">1. this的绑定规则</a><ul><li><a href="#11-默认绑定">1.1 默认绑定</a></li><li><a href="#12-隐式绑定">1.2 隐式绑定</a><ul><li><a href="#121-隐式丢失常见">1.2.1 隐式丢失（常见）</a></li><li><a href="#122-隐式丢失传入回调函数时">1.2.2 隐式丢失（传入回调函数时）</a></li></ul></li><li><a href="#13显示绑定">1.3显示绑定</a><ul><li><a href="#131-硬绑定">1.3.1 硬绑定</a></li><li><a href="#132-api调用的上下文">1.3.2 API调用的上下文</a></li></ul></li><li><a href="#14-new绑定">1.4 new绑定</a></li></ul></li><li><a href="#2-回调函数里的this常见">2. 回调函数里的this（常见）</a><ul><li><a href="#21-箭头函数的另一个经典例子">2.1 箭头函数的另一个经典例子</a></li></ul></li></ul><!-- tocstop --><h4><span id="1-this的绑定规则">1. this的绑定规则</span></h4><h5><span id="11-默认绑定">1.1 默认绑定</span></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a=<span class="number">2</span>;</span><br><span class="line">foo();<span class="comment">//2</span></span><br></pre></td></tr></table></figure><a id="more"></a><h5><span id="12-隐式绑定">1.2 隐式绑定</span></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1=&#123;</span><br><span class="line">    a:<span class="number">2</span>,</span><br><span class="line">    foo:foo,</span><br><span class="line">    obj2:obj2</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2=&#123;</span><br><span class="line">    a:<span class="number">42</span>,</span><br><span class="line">    foo:foo</span><br><span class="line">&#125;;</span><br><span class="line">obj1.foo();<span class="comment">//2</span></span><br><span class="line">obj1.obj2.foo();<span class="comment">//42</span></span><br></pre></td></tr></table></figure><h6><span id="121-隐式丢失常见">1.2.1 隐式丢失（常见）</span></h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    a:<span class="number">2</span>,</span><br><span class="line">    foo:foo</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar =obj.foo;<span class="comment">//函数别名！丢失绑定对象，会应用默认绑定</span></span><br><span class="line"><span class="keyword">var</span> a=<span class="string">"global"</span>;</span><br><span class="line">bar();<span class="comment">//"global"</span></span><br></pre></td></tr></table></figure><h6><span id="122-隐式丢失传入回调函数时">1.2.2 隐式丢失（传入回调函数时）</span></h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doFoo</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    fn();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    a:<span class="number">2</span>,</span><br><span class="line">    foo:foo</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a=<span class="string">"global"</span>;</span><br><span class="line">doFoo(obj.foo);<span class="comment">//"global",回掉函数丢失this绑定是非常常见的</span></span><br></pre></td></tr></table></figure><h5><span id="13显示绑定">1.3显示绑定</span></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    a:<span class="number">2</span>,</span><br><span class="line">    foo:foo</span><br><span class="line">&#125;;</span><br><span class="line">foo.call(obj);<span class="comment">//2,把this强制绑定到obj上，但还是无法解决隐式绑定中的绑定丢失</span></span><br></pre></td></tr></table></figure><h6><span id="131-硬绑定">1.3.1 硬绑定</span></h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    a:<span class="number">2</span>,</span><br><span class="line">    foo:foo</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    foo.call(obj);</span><br><span class="line">&#125;</span><br><span class="line">bar();<span class="comment">//2</span></span><br><span class="line">setTimeout(bar,<span class="number">100</span>);<span class="comment">//2</span></span><br><span class="line">bar.call(<span class="built_in">window</span>);<span class="comment">//2,硬绑定的bar不可能再修改它的this</span></span><br></pre></td></tr></table></figure><h6><span id="132-api调用的上下文">1.3.2 API调用的上下文</span></h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">el</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(el,<span class="keyword">this</span>.id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    id:<span class="string">"awesome"</span></span><br><span class="line">&#125;</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].forEach(foo,obj);<span class="comment">//第二个参数的obj,用来指定foo中this的指向</span></span><br><span class="line"> <span class="comment">//输出为：1 awesome 2 awesome 3 awesome</span></span><br></pre></td></tr></table></figure><h5><span id="14-new绑定">1.4 new绑定</span></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a=a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar =<span class="keyword">new</span> foo(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bar.a);</span><br></pre></td></tr></table></figure><p><br></p><blockquote><p>&emsp;&emsp;<br>&emsp;&emsp;四类绑定的优先级：new绑定&gt;显示绑定&gt;隐式绑定&gt;默认绑定<br><br></p></blockquote><h4><span id="2-回调函数里的this常见">2. 回调函数里的this（常见）</span></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    name:<span class="string">'wt'</span>,</span><br><span class="line">    foo1:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);<span class="comment">//Object&#123;name:'wt'&#125;</span></span><br><span class="line">        <span class="keyword">var</span> _this=<span class="keyword">this</span>;<span class="comment">//用_this保存this的指向</span></span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>);<span class="comment">//Window</span></span><br><span class="line">            <span class="built_in">console</span>.log(_this);<span class="comment">//Object&#123;name:'wt'&#125;</span></span><br><span class="line">        &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    foo2:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);<span class="comment">//Object&#123;name:'wt'&#125;</span></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>);<span class="comment">//Object&#123;name:'wt'&#125;</span></span><br><span class="line">        &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用1  </p><p>&emsp;&emsp;<code>obj.foo1();//结果见上面代码的注释</code></p><p>调用2  </p><p>&emsp;&emsp;<code>obj.foo2();</code><br>&emsp;&emsp;1,2两个方法同时调用的话，两个setTimeout会稍后执行，先执行foo1和foo2的<code>console.log(this)</code>,打印顺序不一样。这里的foo2相当于：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo2:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="keyword">this</span>)&#125;.bind(<span class="keyword">this</span>),<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用3</p><p><code>var f=obj.foo1;//或f=obj.foo2</code><br><code>f();//this全部指向Window</code></p><h5><span id="21-箭头函数的另一个经典例子">2.1 箭头函数的另一个经典例子</span></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span><span class="function">(<span class="params">a</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);<span class="comment">//this继承自foo</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1=&#123;</span><br><span class="line">    a:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2=&#123;</span><br><span class="line">    a:<span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar=foo.call(obj1);</span><br><span class="line">bar.call(obj2);<span class="comment">//2,不是3！</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-this的绑定规则&quot;&gt;1. this的绑定规则&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#11-默认绑定&quot;&gt;1.1 默认绑定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#12-隐式绑定&quot;&gt;1.2 隐式绑定&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#121-隐式丢失常见&quot;&gt;1.2.1 隐式丢失（常见）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#122-隐式丢失传入回调函数时&quot;&gt;1.2.2 隐式丢失（传入回调函数时）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#13显示绑定&quot;&gt;1.3显示绑定&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#131-硬绑定&quot;&gt;1.3.1 硬绑定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#132-api调用的上下文&quot;&gt;1.3.2 API调用的上下文&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#14-new绑定&quot;&gt;1.4 new绑定&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-回调函数里的this常见&quot;&gt;2. 回调函数里的this（常见）&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#21-箭头函数的另一个经典例子&quot;&gt;2.1 箭头函数的另一个经典例子&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;
&lt;h4 id=&quot;1-this的绑定规则&quot;&gt;&lt;a href=&quot;#1-this的绑定规则&quot; class=&quot;headerlink&quot; title=&quot;1. this的绑定规则&quot;&gt;&lt;/a&gt;1. this的绑定规则&lt;/h4&gt;&lt;h5 id=&quot;1-1-默认绑定&quot;&gt;&lt;a href=&quot;#1-1-默认绑定&quot; class=&quot;headerlink&quot; title=&quot;1.1 默认绑定&quot;&gt;&lt;/a&gt;1.1 默认绑定&lt;/h5&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.a);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a=&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;foo();&lt;span class=&quot;comment&quot;&gt;//2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="你不知道的JavaScript" scheme="https://wtlemoney.github.io/categories/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://wtlemoney.github.io/tags/JavaScript/"/>
    
      <category term="blogs" scheme="https://wtlemoney.github.io/tags/blogs/"/>
    
  </entry>
  
  <entry>
    <title>我为什么要写博客</title>
    <link href="https://wtlemoney.github.io/2018/03/25/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%86%99%E5%8D%9A%E5%AE%A2/"/>
    <id>https://wtlemoney.github.io/2018/03/25/我为什么写博客/</id>
    <published>2018-03-25T15:21:10.000Z</published>
    <updated>2018-04-16T01:43:42.340Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;首先，我是一个从零开始的前端自学者，断断续续学了几个月的时间，留下了3个要满的手写笔记本，几本重点画了又画的前端书籍，以及电脑上数不清的手敲代码的各类文件夹。通过很多网站看了很多前端知识，然而现在…几乎忘的差不多了。我发现一个事实，自己一直在“学”，没有好好的总结，更不用说“习”了。所以，为啥要搞博客这么高端大气上档次的东西咧，总结一下主要有下面几点原因：  </p><ul><li><strong>面试被血虐</strong> </li></ul><p>&emsp;&emsp;前两天的腾讯实习生面试加笔试，把我虐的一塌糊涂。尽管我知道我自己菜，但没想到面完之后感觉自己也太菜了吧。很多问题其实都是平时遇到过的，只不过自己没有独立思考过原理和本质，回答的太不顺利。所以想通过博客这一平台，总结自己学习的知识，来检验自己是否真的掌握了。<br><a id="more"></a></p><ul><li><strong>语言逻辑差</strong></li></ul><p>&emsp;&emsp; 很多以为自己懂了的知识点，其实在面试官面前说出来就变味道了。语言没有任何逻辑性。这样很不好啊，听的人很累的呀，希望能多提高一下语言表达能力。 </p><ul><li><strong>梳理总结知识</strong></li></ul><p>&emsp;&emsp;记了那么多的笔记，翻起来还是相当以及极其之困难的，基本上也没翻过，都是百度。所以趁机好好整理我的宝贝笔记，把精华全部放到我的博客上。可以方便自己“习”，能帮到其他学习前端的同学就再好不过了。  </p><ul><li><strong>提高写作能力</strong></li></ul><p>&emsp;&emsp;微信读书看过不少书，特别欣赏能写出一首好文章的人。我写作能力高中就菜，希望通过自己坚持写博客，提高一下自己的写作水平，毕竟妹子还是搞点文艺犯比较招人喜欢的吧。</p><p>&emsp;&emsp;我的心路历程就是这样子滴。你看吧，说话真的没啥逻辑可言。<br>&emsp;&emsp;希望自己多多总结，找个好工作！<br>&emsp;&emsp;送给自己一些字符串：  </p><p><center><font color="blue" size="3">“越努力越幸运”</font></center></p><p><center><font color="blue" size="3">“远离舒适区”</font></center></p><p><center><font color="blue" size="3">“不能丧”</font></center><br>&emsp;&emsp;此处应附上我的美丽自拍和心灵鸡汤：</p><div align="center"><br>    <img src="/2018/03/25/我为什么写博客/beauty.jpg" width="180" height="180" alt="我的自拍"><br></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;首先，我是一个从零开始的前端自学者，断断续续学了几个月的时间，留下了3个要满的手写笔记本，几本重点画了又画的前端书籍，以及电脑上数不清的手敲代码的各类文件夹。通过很多网站看了很多前端知识，然而现在…几乎忘的差不多了。我发现一个事实，自己一直在“学”，没有好好的总结，更不用说“习”了。所以，为啥要搞博客这么高端大气上档次的东西咧，总结一下主要有下面几点原因：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;面试被血虐&lt;/strong&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;前两天的腾讯实习生面试加笔试，把我虐的一塌糊涂。尽管我知道我自己菜，但没想到面完之后感觉自己也太菜了吧。很多问题其实都是平时遇到过的，只不过自己没有独立思考过原理和本质，回答的太不顺利。所以想通过博客这一平台，总结自己学习的知识，来检验自己是否真的掌握了。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="碎碎念" scheme="https://wtlemoney.github.io/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="blogs" scheme="https://wtlemoney.github.io/tags/blogs/"/>
    
      <category term="碎碎念" scheme="https://wtlemoney.github.io/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
</feed>
